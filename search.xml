<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>大数求余算法</title>
    <url>/%E5%A4%A7%E6%95%B0%E6%B1%82%E4%BD%99%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>今天写了剑指offer上面试题14，剪绳子题目，需要用到大数取余算法，特写下这篇文章以学习大数求余算法</p>
<a id="more"></a>
<p>[toc]</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h3><p><img src="/%E5%A4%A7%E6%95%B0%E6%B1%82%E4%BD%99%E7%AE%97%E6%B3%95/剪绳子2.png" alt></p>
<p>其中：</p>
<script type="math/tex; mode=display">
x^N\%P，P=1000000007,1<N<=1000</script><h3 id="1-大数取余方法"><a href="#1-大数取余方法" class="headerlink" title="1 大数取余方法"></a>1 大数取余方法</h3><p>整数求余满足的性质：</p>
<script type="math/tex; mode=display">
(x*y)mod(p)=[x(y mod p)]mod p=[(xmodp)(ymodp)]modp</script><h4 id="1-循环求余"><a href="#1-循环求余" class="headerlink" title="(1) 循环求余"></a>(1) 循环求余</h4><p>依次求x^1,x^2,…x^n-1对p得余数，使得每一个余数均在可保存得范围内</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//x^n%p</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remainder</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> n,<span class="keyword">int</span> p)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        res =(res*x)%p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="2-快速幂"><a href="#2-快速幂" class="headerlink" title="(2)快速幂"></a>(2)快速幂</h4><p>求a ^ b，快速幂的基本思路：</p>
<p>1）当<strong>b是奇数</strong>时，那么有 <strong>a^b = a * a^(b-1)</strong></p>
<p>2）当<strong>b是偶数</strong>时，那么有 <strong>a^b = a^(b/2) * a^(b/2)</strong></p>
<p>再根据模运算得性质a * a^(b-1)</p>
<p><img src="/%E5%A4%A7%E6%95%B0%E6%B1%82%E4%BD%99%E7%AE%97%E6%B3%95/2.png" style="zoom: 33%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归写法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remainder</span><span class="params">(<span class="keyword">int</span> a ,<span class="keyword">int</span> b,<span class="keyword">int</span> p)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b%<span class="number">2</span>==<span class="number">1</span>)<span class="comment">//奇数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> a*remainder(a,b-<span class="number">1</span>,p)%m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> tmp = remainder(a,b/<span class="number">2</span>,p)%m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> (tmp*tmp)%m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归写法，位运算思想</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**将b写成二进制，如2^13=2^8*2^4*2^1,13=1101</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*循环判断b末尾是否是1，是1,res*=b</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* a=a*a，b右移一位</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*直到b&lt;=0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//PS：当a b p过大时，要将res和a设为long</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remainder</span><span class="params">(<span class="keyword">int</span> a ,<span class="keyword">int</span> b,<span class="keyword">int</span> p)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> res= <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>==<span class="number">1</span>)&#123;<span class="comment">//or b%2==1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        	res=(res*a)%p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        a=(a*a)%p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="2-问题解答"><a href="#2-问题解答" class="headerlink" title="2 问题解答"></a>2 问题解答</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**关键点，求出3^(k-1),令res=3^(k-1)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    *令n=3k+b, k =n/3,b=b%3;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    *(1) b=0 最大乘积:res*3;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    *(2) b=1 ,1+3&lt;2*2,最大乘积:res*4;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    *(3) b=2,最大乘积:res*6; </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    **/</span>   </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> b = n % <span class="number">3</span>, k = n / <span class="number">3</span> - <span class="number">1</span>, p = <span class="number">1000000007</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>, a = <span class="number">3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;<span class="comment">//快速幂，求3^(k-1)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> ((k &amp; <span class="number">1</span>) == <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                res = (res * a) % p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            a = (a * a) % p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            k &gt;&gt;= <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) (res * <span class="number">3</span> % p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) (res * <span class="number">4</span> % p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (res * <span class="number">6</span> % p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Coding</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode</title>
    <url>/leetcode/</url>
    <content><![CDATA[<p>与LeetCode的相爱相杀，在解题中找到编程的乐趣，记录解题思路与你共同探讨；</p>
<p>Ps：Num+数字为LeetCode中相应题目编号</p>
<p>用回溯法解决问题三部曲:</p>
<ol>
<li>画递归树</li>
<li>对递归树编码</li>
<li>找出终止条件，回溯</li>
</ol>
<a id="more"></a>
<hr>
<p>[toc]</p>
<h2 id="一-二叉树类"><a href="#一-二叉树类" class="headerlink" title="一    二叉树类"></a>一    二叉树类</h2><h3 id="Num-113-路径总和"><a href="#Num-113-路径总和" class="headerlink" title="Num 113:路径总和"></a>Num 113:路径总和</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*题目描述：给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans_path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;Integer&gt; node_path = <span class="keyword">new</span> ArrayList&lt;&gt;();       </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        path_sum(root,sum);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> ans_path;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//整体思路：回溯,先序遍历思想，根左右</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">path_sum</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="comment">//空结点直接处理</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        node_path.add(root.val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;<span class="comment">//叶子节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(sum==root.val)&#123;<span class="comment">//当前值等于路径值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                ans_path.add(<span class="keyword">new</span> ArrayList&lt;&gt;(node_path));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sum-=root.val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            path_sum(root.left,sum);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">             path_sum(root.right,sum);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        node_path.remove(node_path.size()-<span class="number">1</span>);<span class="comment">//回溯</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="Num-129-根节点到叶子节点之和"><a href="#Num-129-根节点到叶子节点之和" class="headerlink" title="Num 129:根节点到叶子节点之和"></a>Num 129:根节点到叶子节点之和</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*	题目描述:给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*	输入: [1,2,3]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*    1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*   / \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*  2   3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*	输出: 25</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*	解释:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*	从根到叶子节点路径 1-&gt;2 代表数字 12.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*	从根到叶子节点路径 1-&gt;3 代表数字 13.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*	因此，数字总和 = 12 + 13 = 25.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sumNumber(root,<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//先序遍历思想</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sumNumber</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;<span class="comment">//叶子节点,值直接返回</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            ans += <span class="number">10</span>*sum+root.val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         sumNumber(root.left,<span class="number">10</span>*sum+root.val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">         sumNumber(root.right,<span class="number">10</span>*sum+root.val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="Num-701-二叉搜索树的插入操作"><a href="#Num-701-二叉搜索树的插入操作" class="headerlink" title="Num 701: 二叉搜索树的插入操作"></a>Num 701: 二叉搜索树的插入操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//迭代法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            TreeNode cur = root, p = root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                p = cur;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (cur.val &lt; val) </span></pre></td></tr><tr><td class="code"><pre><span class="line">                    cur = cur.right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">else</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">                    cur = cur.left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            TreeNode new_code = <span class="keyword">new</span> TreeNode(val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (p.val &lt; val) </span></pre></td></tr><tr><td class="code"><pre><span class="line">                p.right = new_code;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                p.left = new_code;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//递归法，函数终止条件,插入新节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (root.val &gt; val)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                root.left = insertIntoBST(root.left, val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                root.right = insertIntoBST(root.right, val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="Num230-二叉搜索树的第k小个元素"><a href="#Num230-二叉搜索树的第k小个元素" class="headerlink" title="Num230 :二叉搜索树的第k小个元素"></a>Num230 :二叉搜索树的第k小个元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 题目描述:给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* 输入: root = [3,1,4,null,2], k = 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*   3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* / \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* 1   4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*   2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* 输出: 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans =<span class="number">0</span>,count=<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        kthSmallests(root,k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//中序遍历思想</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kthSmallests</span><span class="params">(TreeNode root,<span class="keyword">int</span> k)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root ==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        kthSmallests(root.left,k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(++count==k)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ans = root.val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        kthSmallests(root.right,k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="Num-687-最大同值路径"><a href="#Num-687-最大同值路径" class="headerlink" title="Num 687: 最大同值路径"></a>Num 687: 最大同值路径</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**题目描述:给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">输入：         5       输出  ： 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">             / \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">            4   5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">           / \   \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">          1   1   5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/** 三种情况: 1 在左子树中 2 在右子树中 3 左+根+右</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    	递归思路:从根节点出发，依次遍历左、右子树,用left、right表示值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    	(1) 左子树不为空且值与根相等, 加1 ，否则当前左子树的值为0，右子树同理</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    	(2) 用max记录当前最大值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    	(3) 递归返回值为当前左右子树中路径较大的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    **/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode root)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        longestUnivaluePaths(root);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> max;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">longestUnivaluePaths</span><span class="params">(TreeNode root)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> left = longestUnivaluePaths(root.left);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> right = longestUnivaluePaths(root.right);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>&amp;&amp;root.val==root.left.val)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            left= left + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span>  left = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>&amp;&amp;root.val==root.right.val)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            right=right+<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span>  right = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        max = Math.max(max,left+right);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Math.max(left,right);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="Num124-二叉树最大路径和"><a href="#Num124-二叉树最大路径和" class="headerlink" title="Num124  二叉树最大路径和"></a>Num124  二叉树最大路径和</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**题目描述:给定一个非空二叉树，返回其最大路径和。本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	输入: [-10,9,20,null,null,15,7]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">           -10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">           / \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">          9  20</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">            /  \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">           15   7</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    输出: 42</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//1 根+左+右</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//2 左+根  3右+根 4 根</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = Integer.MIN_VALUE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxPathSums(root);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSums</span><span class="params">(TreeNode root)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> left_val = Math.max(maxPathSums(root.left),<span class="number">0</span>);<span class="comment">//负数直接用0代替</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> right_val =Math.max(maxPathSums(root.right),<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ans =Math.max(root.val+left_val+right_val,ans);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> root.val+Math.max(left_val,right_val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="二-链表类"><a href="#二-链表类" class="headerlink" title="二   链表类"></a>二   链表类</h2><h3 id="Num148-链表排序"><a href="#Num148-链表排序" class="headerlink" title="Num148:链表排序"></a>Num148:链表排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*题目描述：在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*输入: 4-&gt;2-&gt;1-&gt;3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*输出: 1-&gt;2-&gt;3-&gt;4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//归并排序思想</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)<span class="comment">//递归出口，只有一个节点或者没有节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ListNode mid_node = get_mid_node(head);<span class="comment">//得到中间节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ListNode right_head = mid_node.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mid_node.next = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> merge_List(sortList(head), sortList(right_head));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">get_mid_node</span><span class="params">(ListNode head)</span> </span>&#123;<span class="comment">//找链表的中间节点，快慢指针法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ListNode low_node = head, fast_node = head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (fast_node.next != <span class="keyword">null</span> &amp;&amp; fast_node.next.next != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            low_node = low_node.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            fast_node = fast_node.next.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> low_node;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge_List</span><span class="params">(ListNode p, ListNode q)</span> </span>&#123;<span class="comment">//合并p,q两个有序链表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ListNode cur_p = p, cur_q = q, head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (p.val &lt; q.val) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            head = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur_p = cur_p.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            head = q;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur_q = cur_q.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ListNode cur = head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (cur_q != <span class="keyword">null</span> &amp;&amp; cur_p != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (cur_q.val &lt; cur_p.val) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                cur.next = cur_q;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                cur_q = cur_q.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                cur = cur.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                cur.next = cur_p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                cur_p = cur_p.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                cur = cur.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (cur_p != <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur.next = cur_p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (cur_q != <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur.next = cur_q;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="Num-92-反转部分链表"><a href="#Num-92-反转部分链表" class="headerlink" title="Num 92:反转部分链表"></a>Num 92:反转部分链表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*题目描述:反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ListNode root = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ListNode cur = head,root_cur = root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">int</span> index = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">while</span>(index!=m)&#123; <span class="comment">//小于m的节点，尾插法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        root_cur.next = cur;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        root_cur=root_cur.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cur=cur.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        index++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ListNode temp = cur;<span class="comment">//暂存当前节点的尾部，记录大于n之后的元素的前驱</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      root_cur.next=<span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//头插法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">while</span>(index&lt;=n)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          head = cur.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          cur.next=root_cur.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          root_cur.next =cur;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          cur = head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         index++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      root_cur = temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span>(cur!=<span class="keyword">null</span>)<span class="comment">//n之后的直接插入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            root_cur.next = c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">return</span> root.next;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="Num61-旋转链表"><a href="#Num61-旋转链表" class="headerlink" title="Num61: 旋转链表"></a>Num61: 旋转链表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**	题目描述:给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/** 分情况讨论：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">        1 head ==null ||k%listnode.size()==0 直接返回结果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">        2 找到链表的倒数第k个节点，将链表的前size-k个节点插入到链表的末尾</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    **/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> list_size = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ListNode cur =head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            list_size++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur=cur.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="comment">//求链表大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        k = k%list_size;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ListNode k_node_last = find_last_k(head,k);<span class="comment">//找到倒数第k个节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        cur = k_node_last;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(cur.next!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur=cur.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="comment">//到链表末尾</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(head!=k_node_last)&#123;<span class="comment">//前size-k个节点插入到后面</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur.next = head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur =head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            head= head.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cur.next =<span class="keyword">null</span>;<span class="comment">//末尾指向空结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> k_node_last;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">find_last_k</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//找到倒数第k个节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ListNode cur=head,pre =head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(++index&lt;k)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur =cur.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(cur.next!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            pre =pre.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur =cur.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> pre;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
<h3 id="Num-86-分割链表"><a href="#Num-86-分割链表" class="headerlink" title="Num 86 :分割链表"></a>Num 86 :分割链表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 题目描述:给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*	输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*	输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/** </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    * 1 小于x的存到一个链表root中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    * 2 大于等于x的放在原链表中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    * 3 1--&gt;2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    **/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ListNode root = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ListNode cur = root,p = head,pre_p=head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(p.val&lt;x)&#123;<span class="comment">//小于x，赋值给新节点，并在原链表中删除该节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                ListNode temp =p.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(p==head)<span class="comment">//考虑首节点小于x,直接移动head</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    head = head.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    pre_p.next = p.next;<span class="comment">//删除p</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                cur.next = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                cur = p;<span class="comment">//尾插法插入小于x的节点到root中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                p = temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//&gt;=x,直接后移</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                pre_p = p;             </span></pre></td></tr><tr><td class="code"><pre><span class="line">                p = p.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cur.next = head;<span class="comment">//合并</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> root.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="Num114-二叉树转为链表"><a href="#Num114-二叉树转为链表" class="headerlink" title="Num114 二叉树转为链表"></a>Num114 二叉树转为链表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**题目描述:给定一个二叉树，原地将它展开为链表。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">例如，Input     Output   </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    1  			1-2-3-4-5-6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">   / \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">  2   5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> / \   \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">3   4   6</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="comment">//找到左孩子的最右边叶节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">if</span>(root.left==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                root=root.right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                TreeNode last_right_node = root.left;<span class="comment">//记录左孩子最右节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">while</span>(last_right_node.right!=<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    last_right_node=last_right_node.right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                last_right_node.right = root.right;<span class="comment">//将根节点的右子树插入到根的左孩子的最右节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                root.right = root.left;<span class="comment">//将最子树插入到根的右子树中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                root.left = <span class="keyword">null</span>;<span class="comment">//根的左孩子置为null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                root = root.right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="comment">//end else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">       &#125;<span class="comment">//end while</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**也可以用先序遍历思想，用栈保存右孩子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">用一个变量保存上次遍历的节点，遍历一个节点将该节点放入pre的右子树中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">左子树置为null**/</span></span></pre></td></tr></table></figure>
<h2 id="三-数组类"><a href="#三-数组类" class="headerlink" title="三  数组类"></a>三  数组类</h2><h3 id="Num560-和位k的子数组"><a href="#Num560-和位k的子数组" class="headerlink" title="Num560:和位k的子数组"></a>Num560:和位k的子数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* Input:[3,4,7,2,-3,1,4,2]  k = 7</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* Output:7</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//key:累计和 value:出现的次数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     map.put(<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//解决数组从第0个元素开始选择</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">int</span> ans = <span class="number">0</span>,sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         sum+=nums[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="comment">//k = sum-(sum-k)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">if</span>(map.containsKey(sum-k))&#123;<span class="comment">//map中包含sum-k,即：当前的累计和sum减去sum-k的累计和等于k</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">             ans+=map.get(sum-k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">         &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            map.put(sum,map.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="Num1-两数之和"><a href="#Num1-两数之和" class="headerlink" title="Num1 两数之和"></a>Num1 两数之和</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**题目描述： 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">Input: nums = [2, 7, 11, 15], target = 9</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">Output: [0, 1] **/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="comment">//Hashmap:key:元素值,value:数组下标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(map.containsKey(target-nums[i]))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            res[<span class="number">0</span>]= i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            res[<span class="number">1</span>] =map.get(target-nums[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        map.put(nums[i],i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="Num15-三数之和"><a href="#Num15-三数之和" class="headerlink" title="Num15 三数之和"></a>Num15 三数之和</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**题目描述:给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">Input:nums = [-1, 0, 1, 2, -1, -4]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">Output:   [[-1, 0, 1], [-1, -1, 2]]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;List&lt;Integer&gt;&gt;  res  =<span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Arrays.sort(nums);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k =<span class="number">0</span>;k&lt;nums.length-<span class="number">2</span>;k++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(nums[k]&gt;<span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//值&gt;0，则后面的值皆大于0，直接跳过</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(k&gt;<span class="number">0</span>&amp;&amp;nums[k]==nums[k-<span class="number">1</span>]) <span class="keyword">continue</span>;<span class="comment">//跳过相同的值，因为此前已经将此值出现的结果存入,防止重复</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> i = k+<span class="number">1</span>,j= nums.length-<span class="number">1</span>;<span class="comment">//i指向k+1,j指向最后一个元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span>(i&lt;j)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> sum = nums[k]+nums[i]+nums[j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(nums[k], nums[i], nums[j])));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">while</span>(i&lt;j&amp;&amp;nums[i]==nums[++i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">while</span>(i&lt;j&amp;&amp;nums[j]==nums[--j]); </span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;<span class="comment">//小于0,i++,滤掉重复</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">while</span>(i&lt;j&amp;&amp;nums[i]==nums[++i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">else</span><span class="comment">//大于0,j--,滤掉重复</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">while</span>(i&lt;j&amp;&amp;nums[j]==nums[--j]);     </span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="Num18：四数之和"><a href="#Num18：四数之和" class="headerlink" title="Num18：四数之和"></a>Num18：四数之和</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**	题目描述:给定一个包含 n 个整数的数组 nums 和一个目标值 target</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    找出所有满足条件且不重复的四元组。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    Input:  nums = [1, 0, -1, 0, -2, 2],target = 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    OutPut: [[-1,  0, 0, 1],  [-2, -1, 1, 2],  [-2,  0, 0, 2]]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//与三数之和类似,固定两个值,双指针指向固定两个值后的第一个和最后一个</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;List&lt;Integer&gt;&gt; res =<span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Arrays.sort(nums);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        HashSet&lt;List&lt;Integer&gt;&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length-<span class="number">3</span>;i++)&#123;<span class="comment">//固定第一个值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;nums.length-<span class="number">2</span>;j++)&#123;<span class="comment">//固定第二个值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> left = j+<span class="number">1</span>,right =nums.length-<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">while</span>(left&lt;right)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">int</span> sum = nums[i]+nums[j]+nums[left]+nums[right];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span>(sum&lt;target)   left++;<span class="comment">//小于target,left右移一位</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target) right--;<span class="comment">//大于target，right左移一位</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        set.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));<span class="comment">//值存入set中,判断结果重复</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                        left++;right--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;<span class="comment">//end while</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="comment">//end for j</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="comment">//end for i</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        res.addAll(set);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="Num39-组合总和"><a href="#Num39-组合总和" class="headerlink" title="Num39 组合总和"></a>Num39 组合总和</h3><p><img src="/leetcode/组合总和.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回溯思想，三部曲</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//1. 画递归树 2. 对递归树编码 3. 找出终止条件，回溯</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(candidates.length==<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dfs(temp,candidates,target,<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt; temp, <span class="keyword">int</span> [] candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> begin)</span></span>&#123;<span class="comment">//为避免重复，每次从begin位置开始</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(target&lt;<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target==<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=begin;i&lt;candidates.length;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    temp.add(candidates[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    dfs(temp,candidates,target-candidates[i],i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    temp.remove(temp.size()-<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="Num40-组合总和II"><a href="#Num40-组合总和II" class="headerlink" title="Num40 组合总和II"></a>Num40 组合总和II</h3><p><img src="/leetcode/组合总和II.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(candidates.length==<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Arrays.sort(candidates);<span class="comment">//排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        dfs(temp,candidates,target,<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt; temp, <span class="keyword">int</span> [] candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> begin)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(target&lt;<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target==<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=begin;i&lt;candidates.length&amp;&amp;target-candidates[i]&gt;=<span class="number">0</span>;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="comment">//排序后，相邻的元素[l,r]的解包含[l+1,r]的解</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span>(i!=begin&amp;&amp;candidates[i]==candidates[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    temp.add(candidates[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    dfs(temp,candidates,target-candidates[i],i+<span class="number">1</span>);<span class="comment">//不能重复使用元素，故从i+1开始遍历</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    temp.remove(temp.size()-<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="Num78-子集"><a href="#Num78-子集" class="headerlink" title="Num78 子集"></a>Num78 子集</h3><p><img src="/leetcode/子集.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//回溯</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dfs(temp,nums,<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt;temp, <span class="keyword">int</span> [] nums,<span class="keyword">int</span> start)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(start==nums.length)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;nums.length;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            temp.add(nums[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            dfs(temp,nums,i+<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            temp.remove(temp.size()-<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以[1,2,3]为例 用temp依次获取ans中的值，初始ans=[[]],记录当前ans的大小len并遍历，再依次在temp中加入当前nums[i]值后放入ans</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/**(1)len=1,temp=[],加入nums[0],temp=[1],放入ans中,ans=[[],[1]]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">(2) len=2,temp可以取[]和[1],加入nums[1],temp为[2]和[1,2],ans=[[],[1],[2],[1,2]]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">(3) len =4 ,temp可以取[]、[1]、[2]、[1,2],依次加入nums[2],temp为[3]、[1,3]、[2,3]和[1,2,3],ans=[[]、[1]、[2]、[1,2],[3],[1,3],[2,3],[1,2,3]]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	   List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            List&lt;Integer&gt;  temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> len = ans.size();<span class="comment">//获取此时ans的长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;len;j++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              temp = <span class="keyword">new</span> ArrayList&lt;&gt;(ans.get(j));<span class="comment">//实例化中ans的每个值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">              temp.add(nums[i]);<span class="comment">//加入当前值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">              ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(temp));<span class="comment">//放进ans中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**位运算</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 求数组的所有子集</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 位运算的思想 ，长度为n的数组共有2^n个子集，按1取数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 如5=101，即可以取第一个数和第3个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> * 7=111，可以取第1、2、3个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; getSubset(ArrayList&lt;Integer&gt; list) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (list.size() &gt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; Math.pow(<span class="number">2</span>, list.size()); i++) &#123;<span class="comment">//长度为n的数组共有2^n个子集</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> index = i;<span class="comment">//获取当前位</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; list.size(); j++) &#123;<span class="comment">//n位数，二进制位共有n位，每位代表一个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> ((index &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        temp.add(list.get(j));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    index &gt;&gt;= <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                result.add(temp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> result;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
<h2 id="四-字符串类"><a href="#四-字符串类" class="headerlink" title="四 字符串类"></a>四 字符串类</h2><h3 id="Num-3-无重复字符的最长子串"><a href="#Num-3-无重复字符的最长子串" class="headerlink" title="Num 3  无重复字符的最长子串"></a>Num 3  无重复字符的最长子串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">Input:	abcabcbb		bbbbb		pwwkew</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">Output:		3			 1			  3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//滑动窗口思想，每一个map中记录每个字符出现的位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        HashMap&lt;Character,Integer&gt; map =<span class="keyword">new</span> HashMap&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>,left=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i)))&#123;<span class="comment">//已经含有该字符，更新left的位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                left = Math.max(map.get(s.charAt(i)),left); </span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            res = Math.max(res,i-left+<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            map.put(s.charAt(i),i+<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="Num42-最长有效括号"><a href="#Num42-最长有效括号" class="headerlink" title="Num42 最长有效括号"></a>Num42 最长有效括号</h3><p><img src="/leetcode/最长有效括号.png" alt="image-20200301220106013" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我的解法,效率低</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;Integer&gt; list =<span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">')'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    list.add(stack.peek());<span class="comment">//添加(的下标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    list.add(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    stack.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                stack.add(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Collections.sort(list);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//问题转化为求list两个数连续相差1的最大长度问题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, tmp = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; list.size(); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (list.get(i) - list.get(i - <span class="number">1</span>) == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (tmp == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    tmp++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                tmp++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                </span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                res = Math.max(res, tmp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                tmp = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        res = Math.max(res, tmp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//栈的另一种解法,直接在出栈时求出最大长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        stack.push(-<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>)<span class="comment">//'(' 直接入当前(所在下标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                stack.push(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//=')'直接出栈</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                stack.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (stack.isEmpty()) &#123;<span class="comment">//若此时栈中为空，代表之前所有的括号均以匹配完成，将当前下标入栈(与刚开始放入-1类似)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    stack.push(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span><span class="comment">//若此时栈中拥有元素，更新最大长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="comment">//比较res与(i-当前栈顶元素)即当前最大有效长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    res = Math.max(res, i - stack.peek());</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态规划思想</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (s.charAt(i) == <span class="string">')'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">'('</span>) &#123;<span class="comment">//...(),前一个是( ,...的长度加上当前匹配上的括号长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                        dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] + <span class="number">2</span> : <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="comment">//需要找到i-1-dp[i-1],即前一个)所匹配的(前面的一个字符是不是()有效长度的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="comment">//如"()()(())" ,i=7时,i-1-dp[i-1]=4 s.charAt(4)='('，此时可以匹配为有效长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="number">1</span>] - <span class="number">1</span>) == <span class="string">'('</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="comment">//1((2)3) ，dp[i-1] 对应2,dp[i-2-dp[i-1]]对应1,+2对应3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                        dp[i] = (i - dp[i - <span class="number">1</span>] &gt; <span class="number">1</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + dp[i - <span class="number">1</span>] + <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    res = Math.max(dp[i], res);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//reference: https://leetcode.wang/leetCode-32-Longest-Valid-Parentheses.html</span></span></pre></td></tr></table></figure>
<h2 id="五-LeetCode周赛系列"><a href="#五-LeetCode周赛系列" class="headerlink" title="五 LeetCode周赛系列"></a>五 LeetCode周赛系列</h2><h3 id="第178周周赛"><a href="#第178周周赛" class="headerlink" title="第178周周赛"></a>第178周周赛</h3><h4 id="1-有多少小于当前数字的数字"><a href="#1-有多少小于当前数字的数字" class="headerlink" title="1 有多少小于当前数字的数字"></a>1 有多少小于当前数字的数字</h4><p>题目链接： <a href="https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暴力法 时间复杂度：o(n2)，空间复杂度o(1)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallerNumbersThanCurrent(<span class="keyword">int</span>[] nums) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> [] res =<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(j==i) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[j])</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    res[i]++;   </span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//桶排序思想，时间复杂度：o(n)，空间复杂度:常树 o(101)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] smallerNumbersThanCurrent(<span class="keyword">int</span>[] nums) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> []  bucket =<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>];<span class="comment">//记录nums[i]出现的次数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        bucket[num]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//从头开始遍历bucket，用pre记录小于nums[i]的数字出现的次数，再更新bucket[nums[i]],得到当前小于nums[i]的数字个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> pre=<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bucket.length;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> tmp = bucket[i];<span class="comment">//保留当前出现的次数，以便赋值给pre</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        bucket[i] = pre;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pre += tmp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> [] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.length;i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        res[i] = bucket[nums[i]];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="2-通过投票对团队排名"><a href="#2-通过投票对团队排名" class="headerlink" title="2 通过投票对团队排名"></a>2 通过投票对团队排名</h4><p>问题链接：<a href="https://leetcode-cn.com/problems/rank-teams-by-votes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/rank-teams-by-votes/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**思路：1 用hashmap记录每支队伍投票的排名结果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">key:队伍号 value:int[n] n为队伍数，也是获取投票可能出现的排名长度数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">如投票结果为["ABC","ACB","ABC","ACB","ACB"] ,则有&lt;A,[5,0,0]&gt;,&lt;B,[0,2,3]&gt;,&lt;C,[0,3,2]&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">2 排序，将HashMap转成含有Map.Entry()的List，并按照每个value的结果进行重大到小排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">rankTeams</span><span class="params">(String[] votes)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> n = votes[<span class="number">0</span>].length();<span class="comment">//参赛队伍数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> votes[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String s = votes[<span class="number">0</span>];<span class="comment">//随意获取一个投票结果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        HashMap&lt;Character, <span class="keyword">int</span>[]&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//记录每一队的排名</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; votes.length; i++) &#123;<span class="comment">//在每个队伍中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> index = votes[i].indexOf(s.charAt(j));<span class="comment">//每个投票人对第i支队伍的打分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                tmp[index]++;<span class="comment">//对应的评分位置打分数加1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            map.put(s.charAt(j), tmp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//key-value都是Map.Entry中的属性，key为Character类型 value为int[] 类型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//map.entrySet()可以获取到Map里面存放的所有键值对</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;Map.Entry&lt;Character, <span class="keyword">int</span>[]&gt;&gt; teamRankList = <span class="keyword">new</span> ArrayList&lt;&gt;(map.entrySet());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Collections.sort(teamRankList, (team1, team2) -&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span>[] rank1 = team1.getValue();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span>[] rank2 = team2.getValue();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rank1.length; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (rank1[i] != rank2[i])<span class="comment">//按照排名降序排列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span> rank2[i] - rank1[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> team1.getKey() - team2.getKey();<span class="comment">//按照队伍字母升序排列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; teamRankList.size(); i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            res.append(teamRankList.get(i).getKey());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> res.toString();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
<h4 id="3-二叉树中的列表"><a href="#3-二叉树中的列表" class="headerlink" title="3 二叉树中的列表"></a>3 二叉树中的列表</h4><p>题目链接：<a href="https://leetcode-cn.com/problems/linked-list-in-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-in-binary-tree/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要考虑到二重递归问题，应先递归根节点判断是否满足要求，不满足再依次判断其左右孩子是否满足题目要求</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubPath</span><span class="params">(ListNode head, TreeNode root)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">if</span>(head==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> dfs(head,root)||isSubPath(head,root.left)||isSubPath(head,root.right);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(ListNode head, TreeNode root)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>||(head.val!=root.val))</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span>  dfs(head.next,root.left)||dfs(head.next,root.right);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>刷题</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer</title>
    <url>/%E5%89%91%E6%8C%87offer/</url>
    <content><![CDATA[<p>手撕代码系列之剑指offer中的典型题目</p>
<a id="more"></a>
<p>[toc]</p>
<h3 id="1-数组中重复的数字-03"><a href="#1-数组中重复的数字-03" class="headerlink" title="1 数组中重复的数字(03)"></a>1 数组中重复的数字(03)</h3><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 输入：[2, 3, 1, 0, 2, 5, 3]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">输出：2 或 3 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//nums[index]==num[nums[index]]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//要求index位置的值nums[index]满足nums[index]==index</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span>(i!=nums[i])&#123;<span class="comment">//当第i个位置的值不等于i时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">//如: 3 2 1 3 0 2 5 3 nums[0]=3,nums[nums[0]]=nums[3]=3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(nums[i]==nums[nums[i]])<span class="comment">//如果第i位置的值与第nums[i]个位置的值相等，即重复值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">return</span> nums[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> temp = nums[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                nums[i]=nums[temp];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                nums[temp]=temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//也可以利用HashSet存入每个数组元素的值，判断插入成功与否(if(!set.add(nums[i])))</span></span></pre></td></tr></table></figure>
<h3 id="2-二维数组的查找-04"><a href="#2-二维数组的查找-04" class="headerlink" title="2  二维数组的查找(04)"></a>2  二维数组的查找(04)</h3><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Input:[ [1,   4,  7, 11, 15], [2,   5,  8, 12, 19],</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">		   [3,   6,  9, 16, 22],[10, 13, 14, 17, 24],</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">		   [18, 21, 23, 26, 30]] 		 target=5,40</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	OutPut:true,false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//类似于二分查找，从右上角开始查询</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(matrix.length==<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> row=  matrix.length,col = matrix[<span class="number">0</span>].length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,j=col-<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(i&lt;row&amp;&amp;j&gt;=<span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(matrix[i][j]==target)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j]&gt;target)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            j--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            i++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="3-从头到尾打印链表-06"><a href="#3-从头到尾打印链表-06" class="headerlink" title="3 从头到尾打印链表(06)"></a>3 从头到尾打印链表(06)</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入：head = [1,3,2]  输出：[2,3,1]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//1 反转链表并求长度 2 赋值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ListNode pre = <span class="keyword">null</span>, cur = head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        size++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ListNode temp = cur.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cur.next = pre;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pre = cur;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cur = temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (pre != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        res[i++] = pre.val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pre = pre.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//也可以将链表值压入栈中 再依次取出</span></span></pre></td></tr></table></figure>
<h3 id="4-重建二叉树-07"><a href="#4-重建二叉树-07" class="headerlink" title="4  重建二叉树(07)"></a>4  重建二叉树(07)</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都<strong>不含重复的数字</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Input:前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7]  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//map中存放中序遍历的值的索引位置，便于找到前序遍历中根节点所在位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        map.put(inorder[i], i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> buildTree(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> pre_L, <span class="keyword">int</span> pre_R, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> in_L, <span class="keyword">int</span> in_R)</span> </span>&#123;<span class="comment">//左闭右闭区间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//递归终止条件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (pre_L &gt; pre_R) <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(preorder[pre_L]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> pivot = map.get(preorder[pre_L]);<span class="comment">//找到中序遍历中根节点的位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> left_size = pivot - in_L;<span class="comment">//左子树的大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    root.left = buildTree(preorder, pre_L + <span class="number">1</span>, pre_L + left_size, inorder, in_L, pivot - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    root.right = buildTree(preorder, pre_L + left_size + <span class="number">1</span>, pre_R, inorder, pivot + <span class="number">1</span>, in_R);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//难点，确定左右子树的边界</span></span></pre></td></tr></table></figure>
<h3 id="5-两个栈实现一个队列-09"><a href="#5-两个栈实现一个队列-09" class="headerlink" title="5 两个栈实现一个队列(09)"></a>5 两个栈实现一个队列(09)</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队尾插入元素时，在A中直接插入元素 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//删除队头元素时，判断B中是否含有元素，有则直接删除，没有将A中元素插入到B中再删</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt;  A ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt; B ;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    A = <span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//先</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    B= <span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//后</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;<span class="comment">//插入时要确保A中没有元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    A.push(value);                </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(!B.isEmpty())<span class="comment">//B不为空</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> B.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(!A.isEmpty())<span class="comment">//B为空，将A中的元素移入B中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        B.push(A.pop());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> B.isEmpty()?-<span class="number">1</span>: B.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//另一种思路：(栈底为队头，栈头为队尾，目的要将两者颠倒)用A做主栈，B做辅助栈，队尾插入时:先判断A中是否含有元素，有则移入B中，插入当前元素后再将B中元素移入到A中；删除队头元素则直接删除A的栈顶元素</span></span></pre></td></tr></table></figure>
<h3 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6 旋转数组的最小数字"></a>6 旋转数组的最小数字</h3><p><img src="/%E5%89%91%E6%8C%87offer/旋转数组.png" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//数组默认递增，经过旋转</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//两种思路:1 直接遍历，找出最小数字 时间复杂度为O(N)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**2 二分查找思想，利用mid与right两个值做判断，时间复杂度(Log N)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    **/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>,right=numbers.length-<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> mid =left+(right-left)/<span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(numbers[mid]&gt;numbers[right])<span class="comment">//中间比右边大，最小值在右半部分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    left=mid+<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid]&lt;numbers[right])<span class="comment">//中间比右边小，近似有序，左半部分，可能包含mid</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="comment">//[3,1,2]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    right=mid;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">else</span> right--;<span class="comment">//相等则去除重复</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> numbers[left];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="7-矩阵路径-12"><a href="#7-矩阵路径-12" class="headerlink" title="7 矩阵路径(12)"></a>7 矩阵路径(12)</h3><p><img src="/%E5%89%91%E6%8C%87offer/矩阵路径.png" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深度优先搜索+回溯  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">char</span>[] words = word.toCharArray();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> row =  board.length,col =  board[<span class="number">0</span>].length;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="keyword">if</span>(dfs(board,i,j,words,<span class="number">0</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">char</span>[] words,<span class="keyword">int</span> k)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//终止条件:数组越界或值不相等时，返回false</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||i&gt;=board.length||j&gt;=board[<span class="number">0</span>].length||board[i][j]!=words[k])</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//值相等且已经找到最后一个值时，即已经找到一条路径</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(k==words.length-<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//遍历每个路径后将其标记，遍历后需要返回访问其状态，回溯思想</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">char</span> tmp =board[i][j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        board[i][j] = <span class="string">'.'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">boolean</span> flag =  dfs(board,i+<span class="number">1</span>,j,words,k+<span class="number">1</span>)||dfs(board,i-<span class="number">1</span>,j,words,k+<span class="number">1</span>)|| </span></pre></td></tr><tr><td class="code"><pre><span class="line">                        dfs(board,i,j+<span class="number">1</span>,words,k+<span class="number">1</span>)|| dfs(board,i,j-<span class="number">1</span>,words,k+<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        board[i][j] = tmp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> flag;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
<h3 id="8-机器人运动范围-13"><a href="#8-机器人运动范围-13" class="headerlink" title="8 机器人运动范围(13)"></a>8 机器人运动范围(13)</h3><p><img src="/%E5%89%91%E6%8C%87offer/机器人运动范围.png" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两种思路:DFS or BFS</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//1 DFS</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">boolean</span>[][] visited;<span class="comment">//记录以访问过的点，避免重复访问</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> dfs(m, n, k, <span class="number">0</span>, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> sum = add(i) + add(j);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || visited[i][j] || sum &gt; k)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            visited[i][j] = <span class="keyword">true</span>;<span class="comment">//记录访问点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> dfs(m, n, k, i + <span class="number">1</span>, j) + dfs(m, n, k, i - <span class="number">1</span>, j)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    + dfs(m, n, k, i, j - <span class="number">1</span>) + dfs(m, n, k, i, j + <span class="number">1</span>) + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                sum += n % <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                n /= <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> sum;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BFS,类似于层次遍历，借助队列实现</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (queue.size() &gt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span>[] tmp = queue.poll();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> i = tmp[<span class="number">0</span>], j = tmp[<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> sum = add(i) + add(j);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || visited[i][j] || sum &gt; k)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        res++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i + <span class="number">1</span>, j&#125;);<span class="comment">//将当前位置的右边和下方的位置放入队列中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j + <span class="number">1</span>&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="9-剪绳子-14"><a href="#9-剪绳子-14" class="headerlink" title="9 剪绳子(14)"></a>9 剪绳子(14)</h3><p><img src="/%E5%89%91%E6%8C%87offer/剪绳子.png" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 动态规划问题 时间:O(N2) 空间 O(N)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> [] dp =<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];<span class="comment">//dp[i]为长度为i绳子的最大乘积</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        dp[<span class="number">2</span>]=<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">3</span>;i&lt;=n;i++)&#123;<span class="comment">//从3开始遍历</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i-<span class="number">1</span>;j++)&#123;<span class="comment">//从长度为1-(i-1)的绳子开始切割比较</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			   <span class="comment">//求出当前长度为i的绳子的最大乘积</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">//需要比较当前以长度j切割(j*(i-j))和j*dp[i-j]最大的一方</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">//因为i-j长度的绳子的最大乘积不一定是i-j</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                dp[i] = Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j])); </span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> dp[n];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**2 贪心/数学思想</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">   *经数学验证，划分3可以比2的优先级高</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">   *令n=3k+b, k =n/3,b=b%3;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">   *(1) b=0 最大乘积:Math.pow(3,k)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">   *(2) b=1 ,1+3&lt;2*2,最大乘积:3^(k-1)*4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">   *(3) b=2,最大乘积:3^k*2 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> n-<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> k=n/<span class="number">3</span>,b=n%<span class="number">3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b==<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,k-<span class="number">1</span>)*<span class="number">4</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,k)*b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/mian-shi-ti-14-i-jian-sheng-zi-tan-xin-si-xiang-by/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//https://leetcode-cn.com/problems/integer-break/solution/tan-xin-xuan-ze-xing-zhi-de-jian-dan-zheng-ming-py/</span></span></pre></td></tr></table></figure>
<h3 id="10-剪绳子II-14"><a href="#10-剪绳子II-14" class="headerlink" title="10 剪绳子II(14)"></a>10 剪绳子II(14)</h3><p><img src="/%E5%89%91%E6%8C%87offer/剪绳子2.png" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**关键点，求出3^(k-1),令res=3^(k-1)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    *令n=3k+b, k =n/3,b=b%3;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    *(1) b=0 最大乘积:res*3;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    *(2) b=1 ,1+3&lt;2*2,最大乘积:res*4;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    *(3) b=2,最大乘积:res*6; </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    **/</span>   </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> b = n % <span class="number">3</span>, k = n / <span class="number">3</span> - <span class="number">1</span>, p = <span class="number">1000000007</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>, a = <span class="number">3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;<span class="comment">//快速幂，求3^(k-1)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> ((k &amp; <span class="number">1</span>) == <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                res = (res * a) % p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            a = (a * a) % p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            k &gt;&gt;= <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) (res * <span class="number">3</span> % p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) (res * <span class="number">4</span> % p);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (res * <span class="number">6</span> % p);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
<h3 id="11-二进制中1的个数-15"><a href="#11-二进制中1的个数-15" class="headerlink" title="11 二进制中1的个数(15)"></a>11 二进制中1的个数(15)</h3><p><img src="/%E5%89%91%E6%8C%87offer/二进制1的个数.png" alt="image-20200229203908344" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> res =<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">/** 法1 : n&amp;1 依次判断n的每一位是否为1  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">      if((n&amp;1)==1)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">            res++;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">        n&gt;&gt;&gt;=1;**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//法2 :  n&amp;=(n-1)可消除n中最右边的1, 如 n=11010 n-1=11001 n&amp;(n-1)=11000 最右边的1消除了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        res++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        n&amp;=(n-<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="12-数值的整数次方-16"><a href="#12-数值的整数次方-16" class="headerlink" title="12 数值的整数次方(16)"></a>12 数值的整数次方(16)</h3><p><img src="/%E5%89%91%E6%8C%87offer/数值整数次方.png" alt="image-20200229205121960" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 快速幂思想(递归)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//x^n =(x^n/2)^2 令 half_val = x^n/2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//n为偶数 half_val*half_val = x^n;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//n为奇数  half_val*half_val = x^(n-1),如n=5 x^5/2*x^5/2=x^4 ,此时 x^n=x*x^(n-1) =x*half_val*half_val</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            x=<span class="number">1.0</span>/x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> func(x,Math.abs(n));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> n)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">double</span> half_val =  func(x,n/<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> half_val*half_val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> x*half_val*half_val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2 迭代快速幂(位运算思想),将幂划为二进制表示，等于1的位置放入结果中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//2^13=2^8*2^4*2^1  13=1101</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">long</span> y = n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x = <span class="number">1</span> / x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        y = -y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> res = <span class="number">1.0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (y &gt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((y % <span class="number">2</span>) == <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            res *= x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x *= x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="13-链表的倒数第k个节点-22"><a href="#13-链表的倒数第k个节点-22" class="headerlink" title="13 链表的倒数第k个节点(22)"></a>13 链表的倒数第k个节点(22)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快慢指针法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||k==<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ListNode low_node =head,fast_node = head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> cur=<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(cur&lt;k)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            fast_node=fast_node.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(fast_node!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            fast_node =fast_node.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            low_node =low_node.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> low_node;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
<h3 id="14-反转链表-24"><a href="#14-反转链表-24" class="headerlink" title="14 反转链表(24)"></a>14 反转链表(24)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历 或者递归  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="comment">/**  ListNode pre=null,cur=head;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">            while(cur!=null)&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">                ListNode temp = cur.next;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">                cur.next=pre ;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">                pre= cur;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">                cur= temp;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">            &#125; </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">            return pre;**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            ListNode pre =reverseList(head.next);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            head.next.next = head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            head.next =<span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> pre; </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
<h3 id="15-合并两个有序链表-25"><a href="#15-合并两个有序链表-25" class="headerlink" title="15 合并两个有序链表(25)"></a>15 合并两个有序链表(25)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span>(l1==<span class="keyword">null</span>)    <span class="keyword">return</span> l2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">       ListNode cur =head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               cur.next =l1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               cur =l1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               l1=l1.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               cur.next =l2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               cur=l2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               l2=l2.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span>(l1!=<span class="keyword">null</span>) cur.next=l1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">if</span>(l2!=<span class="keyword">null</span>) cur.next=l2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">return</span> head.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr></table></figure>
<h3 id="16-树的子结构-26"><a href="#16-树的子结构-26" class="headerlink" title="16 树的子结构(26)"></a>16 树的子结构(26)</h3><p><img src="/%E5%89%91%E6%8C%87offer/树的子结构.png" alt="image-20200303212345624" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(B==<span class="keyword">null</span>||A==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(B.left==<span class="keyword">null</span>&amp;&amp;B.right==<span class="keyword">null</span>&amp;&amp;B.val==A.val)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(B.val!=A.val) <span class="keyword">return</span> isSubStructure(A.left,B)||isSubStructure(A.right,B);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">boolean</span> match= <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(B.left!=<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">               match&amp;= isSub(A.left,B.left);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(B.right!=<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">               match&amp;=  isSub(A.right,B.right);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> match;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSub</span><span class="params">(TreeNode A,TreeNode B)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(B==<span class="keyword">null</span>||A==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(B.left==<span class="keyword">null</span>&amp;&amp;B.right==<span class="keyword">null</span>&amp;&amp;B.val==A.val)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;   </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(B.val!=A.val)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>; </span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">boolean</span> match= <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(B.left!=<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            match&amp;= isSub(A.left,B.left);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(B.right!=<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            match&amp;=  isSub(A.right,B.right);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> match;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参考讨论区优化递归代码</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(B==<span class="keyword">null</span>||A==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span>  isSub(A,B)||isSubStructure(A.left,B)||isSubStructure(A.right,B);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSub</span><span class="params">(TreeNode A,TreeNode B)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(B==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> B.val==A.val&amp;&amp;isSub(A.left,B.left)&amp;&amp;isSub(A.right,B.right);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
<h3 id="17-二叉树的镜像-27"><a href="#17-二叉树的镜像-27" class="headerlink" title="17  二叉树的镜像(27)"></a>17  二叉树的镜像(27)</h3><p><img src="/%E5%89%91%E6%8C%87offer/二叉树镜像.png" alt="image-20200229225637108" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 递归(DFS) 有三种写法 对应先、中、后序遍历</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//后序遍历写法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="comment">//终止条件，即从叶子节点开始交换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        TreeNode left =   mirrorTree(root.left);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        TreeNode right =  mirrorTree(root.right);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        root.left =right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        root.right =left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2 迭代 层次遍历 BFS思想,借助队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    queue.offer(root);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        TreeNode cur_node = queue.poll();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//交换 left和right</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        TreeNode tmp = cur_node.left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cur_node.left = cur_node.right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cur_node.right = tmp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//cur_node的左右孩子入队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (cur_node.left != <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            queue.offer(cur_node.left);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (cur_node.right != <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            queue.offer(cur_node.right);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="14对称二叉树-28"><a href="#14对称二叉树-28" class="headerlink" title="14对称二叉树(28)"></a>14对称二叉树(28)</h3><p><img src="/%E5%89%91%E6%8C%87offer/对称二叉树.png" alt="image-20200303221630135" style="zoom:67%;"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       <span class="keyword">return</span> isMirror(root,root);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMirror</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>&amp;&amp;root2==<span class="keyword">null</span>)<span class="comment">//两者都为空,说明遍历完成,返回true</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>||root2==<span class="keyword">null</span>)<span class="comment">//有一个为null,不符合要求</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> root1.val==root2.val&amp;&amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               isMirror(root1.left,root2.right)&amp;&amp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               isMirror(root1.right,root2.left);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BFS，层次遍历思想</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Queue&lt;TreeNode&gt; q =<span class="keyword">new</span> LinkedList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        q.offer(root.left);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        q.offer(root.right);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            TreeNode left_node = q.poll();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            TreeNode right_node =q.poll();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(left_node==<span class="keyword">null</span>&amp;&amp;right_node==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(left_node==<span class="keyword">null</span>||right_node==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(left_node.val!=right_node.val)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            q.offer(left_node.left);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            q.offer(right_node.right);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            q.offer(left_node.right);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            q.offer(right_node.left);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Coding</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>笔试题汇总</title>
    <url>/%E7%AC%94%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>  记录笔试中写到的编程题</p>
<a id="more"></a>
<h2 id="爱奇艺"><a href="#爱奇艺" class="headerlink" title="爱奇艺"></a>爱奇艺</h2><h3 id="1-切割块"><a href="#1-切割块" class="headerlink" title="1 切割块"></a>1 切割块</h3><p>有一个x<em>y</em>z的立方体，要在这个立方体上砍k刀，每一刀可以看作是用一个平行于立方体某一面的平面切割立方体，且必须在坐标为整数的位置切割，如在x=0.5处用平面切割是非法的。问在切割k刀之后，最多可以把立方体切割成多少块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Input: 2 2 2 3    OutPut: 8  **/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">max_piece</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> k)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">long</span> max_p = x * y * z;<span class="comment">//最大块数，即体积</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">long</span> max_k = (x - <span class="number">1</span>) + (y - <span class="number">1</span>) + (z - <span class="number">1</span>);<span class="comment">//最大能切的刀数，即每一个边长减1的和</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (k &gt;= max_k) &#123;<span class="comment">//大于最大刀数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> max_p;<span class="comment">//返回体积</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//若k小于最大刀数，给边长排序，从小往大切，确保每一边切的刀数要小于该边的边长</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span>[] arr = &#123;x, y, z&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">long</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Arrays.sort(arr);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k;) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(a &lt; arr[<span class="number">0</span>] &amp;&amp; a == b)   &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                a++;i++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c &lt; arr[<span class="number">1</span>] &amp;&amp;  c == b)   &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                c++;i++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(b &lt; arr[<span class="number">2</span>]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                b++;i++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        max_p = a * b * c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> max_p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>毕业论文学习系列之ECG信号处理</title>
    <url>/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%8BECG%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>该篇文章主要记录撰写毕业论文的过程中对ECG信号处理过程中遇到的问题和知识盲点的总结</p>
<a id="more"></a>
<h2 id="一-单位转换"><a href="#一-单位转换" class="headerlink" title="一 单位转换"></a>一 单位转换</h2><p>频率：f=1/T,T为周期,如1ms = 0.001s, f = 1/0.001=1000Hz 所以 1ms =1000HZ</p>
<p>实验采用AD8232评估板与3引脚ECG监视器配合使用来获取ECG信号，采样率为192HZ,即5.2ms为一拍</p>
<p>其中90％以上的ECG信号能量集中在<strong>0.25Hz～35Hz</strong>之间</p>
<h2 id="二-傅里叶变换"><a href="#二-傅里叶变换" class="headerlink" title="二 傅里叶变换"></a>二 傅里叶变换</h2><ol>
<li><p>时域和频域的理解:    </p>
<p>时域:以<strong>时间作为参照来</strong>观察动态世界的方法我们称其为时域分析</p>
<p>频域:它<strong>不是真实</strong>的，而是一个数学构造。时域是<strong>惟一客观存在的域</strong>，而<strong>频域是一个遵循特定规则的数学范畴</strong>，频域也被一些学者称为上帝视角</p>
</li>
<li><p>傅里叶变换的实质：<strong>频域函数和时域函数</strong>的转换，其中<strong>时域</strong>就是永远<strong>随着时间的变化而变化</strong>的，而<strong>频域</strong>就是<strong>装着装着正余弦波的空间</strong></p>
</li>
</ol>
<h2 id="三-滤波器"><a href="#三-滤波器" class="headerlink" title="三  滤波器"></a>三  滤波器</h2><p>滤波器是一种选频装置，可以使信号中<strong>特定的频率成分</strong>通过，而极大地衰减其他频率成分。利用滤波器的这种选频作用，可以<strong>滤除干扰噪声或进行频谱分析</strong></p>
<p>概念: 滤波器是对<strong>波进行过滤</strong>的器件，是一种让<strong>某一频带内信号通过</strong>，同时又<strong>阻止这一频带外信号通过的电路</strong>。</p>
<h3 id="1-滤波器的作用："><a href="#1-滤波器的作用：" class="headerlink" title="1  滤波器的作用："></a>1  滤波器的作用：</h3><ul>
<li>1、将有用的信号与噪声分离，提高信号的抗干扰性及信噪比；</li>
<li>2、滤掉不感兴趣的频率成分，提高分析精度；</li>
<li>3、从复杂频率成分中分离出单一的频率分量</li>
</ul>
<h3 id="2-滤波器的分类"><a href="#2-滤波器的分类" class="headerlink" title="2  滤波器的分类:"></a>2  滤波器的分类:</h3><ul>
<li><p>低通滤波器(LPF)：</p>
<p>从<strong>0～f2</strong>频率之间，幅频特性平直，它可以使<strong>信号中低于f2的频率</strong>成分几乎不受衰减地通过，而高于f2的频率成分受到极大地衰减</p>
</li>
<li><p>高通滤波器(HPF)</p>
<p>与低通滤波相反，从<strong>频率f1～∞</strong>，其幅频特性平直。它使信号中<strong>高于f1的频率</strong>成分几乎不受衰减地<strong>通过</strong>，而<strong>低于f1</strong>的频率成分将受到<strong>极大地衰减</strong></p>
</li>
<li><p>带通滤波器(BHF)</p>
<p>它的通频带在f1～f2之间。它使信号中<strong>高于f1而低于f2的频率</strong>成分可以不受衰减地通过，而其它成分受到衰减。</p>
</li>
<li><p>带阻滤波器</p>
<p>与带通滤波相反，阻带在频率f1～f2之间。它使信号中<strong>高于f1而低于f2的频率成分受到衰减</strong>，其余频率成分的信号几乎不受衰减地通过</p>
</li>
</ul>
<h3 id="3-matlab-Butter-函数使用"><a href="#3-matlab-Butter-函数使用" class="headerlink" title="3 matlab Butter()函数使用"></a>3 matlab Butter()函数使用</h3><p>Butterworth滤波器，使用方法</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[B,A] = BUTTER(N,Wn,<span class="string">'high'</span>) <span class="comment">% 用来设计高通滤波器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[B,A] = BUTTER(N,Wn,<span class="string">'low'</span>) <span class="comment">% designs a lowpass filter.--低通滤波器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[B,A] = BUTTER(N,Wn)<span class="comment">% 带通滤波器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">% 其中，Wn = [a,b],若采样率为192HZ,设计一个3阶，通带为0.04-20HZ的带通滤波器:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[b,a] = butter(<span class="number">3</span>,[<span class="number">0.02</span>/(<span class="number">192</span>/<span class="number">2</span>) <span class="number">20</span>/(<span class="number">192</span>/<span class="number">2</span>)])</span></pre></td></tr></table></figure>
<h2 id="四-ECG信号HRV分析"><a href="#四-ECG信号HRV分析" class="headerlink" title="四 ECG信号HRV分析"></a>四 ECG信号HRV分析</h2><p>心率变异性(Heart Rate Variability ,HRV)是指逐次心搏间期之间的微小变异特性。HRV分析可作为预测心梗死亡率的指标及预测末期肝病患的预后。</p>
<h3 id="1-HRV周期频率"><a href="#1-HRV周期频率" class="headerlink" title="1 HRV周期频率"></a>1 HRV周期频率</h3><p>HRV周期频率通过时频域变换可分为三分频段:</p>
<ul>
<li><strong>VLF</strong>:超低频（&lt;0.04Hz)  <strong>可能与体温调节及心率中缓慢的变化趋势有关</strong>  </li>
<li><strong>LF</strong>:低频段（0.04-0.15Hz）  <strong>反映心脏交感神经的活性</strong>  </li>
<li><strong>HF</strong>:高频段（0.15-0.4Hz）  <strong>反映心脏迷走神经的活性</strong>  </li>
</ul>
<h3 id="2-ECG信号特征"><a href="#2-ECG信号特征" class="headerlink" title="2 ECG信号特征"></a>2 ECG信号特征</h3><p>每个心动周期的正常心电信号波形中包含一个<strong>P波</strong>，一个<strong>QRS波</strong>、一个<strong>T波</strong>和U波，如下图所示:</p>
<p><img src="/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%8BECG%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/1.jpg" alt></p>
<ul>
<li>P波:左右心房的初级过程引起，波型小，时宽:0.08s-0.11s,波幅&lt;0.25mV</li>
<li>QRS波:P波出现之后，典型的QRS波包括:第一个向下的Q波，第二个尖尖向上的<strong>R波</strong>，最后一个向下的S波<ul>
<li>正常QRS间期为0.01~0.1s,如大于0.12s，则反映室内传导阻滞</li>
</ul>
</li>
<li>T波:代表心室复极的电位变化，与R波方向相同，时宽0.05~0.25s,波幅0.1mV~0.8mV</li>
</ul>
<p>RR 间期：相邻 QRS 波群之间的间距称为 RR 间期，反映心室率。正常情况下，RR间期与 PP 间期一致。 </p>
<h3 id="3-HRV时域分析"><a href="#3-HRV时域分析" class="headerlink" title="3 HRV时域分析"></a>3 HRV时域分析</h3><p>HRV时域分析主要指标:</p>
<p><img src="/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%8BECG%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/2.png" alt></p>
<p>HRV频域分析主要指标：</p>
<p><img src="/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%8BECG%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/3.png" alt></p>
<p>本文内容参考文献：<a href="https://blog.csdn.net/qq_41736609/article/details/79710779" target="_blank" rel="noopener">https://blog.csdn.net/qq_41736609/article/details/79710779</a></p>
<p>​                                <a href="https://www.cnblogs.com/h2zZhou/p/8405717.html" target="_blank" rel="noopener">https://www.cnblogs.com/h2zZhou/p/8405717.html</a></p>
<p>​                                <a href="https://wenku.baidu.com/view/443a758cce84b9d528ea81c758f5f61fb73628bb.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/443a758cce84b9d528ea81c758f5f61fb73628bb.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>python学习系列之sklearn</title>
    <url>/python%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%8Bsklearn/</url>
    <content><![CDATA[<p>python sklearn库中相关api的使用</p>
<a id="more"></a>
<h2 id="1-model-selection"><a href="#1-model-selection" class="headerlink" title="1 model_selection"></a>1 model_selection</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> model_selection</span></pre></td></tr></table></figure>
<p>sklearn.model_selection中的相关api</p>
<p>(1) <strong>train_test_split</strong> : 矩阵随机划分测试集和训练集合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train, X_validation, Y_train, Y_validation = train_test_split(X, y, test_size=<span class="number">0.20</span>, random_state=<span class="number">1</span>, shuffle=<span class="literal">True</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># x_train、X_validation为训练特征文本数据;Y_train, Y_validation 为标签数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># test_size:样本占比，测试集占数据集的比重，如果是整数的话就是样本的数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># random_state :给定random_state后，每次构建的模型是相同的、生成的数据集是相同的、每次的拆分结果也是相同的。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># shuffle:是否打乱数据顺序</span></span></pre></td></tr></table></figure>
<p>(2) cross_val_score:交叉验证</p>
<p>以例子说明含义:若将数据集分为10折，做一次交叉验证，实际上它是计算了十次，将每一折都当做一次测试集，其余九折当做训练集，这样循环十次。通过传入的模型，训练十次，最后将十次结果求平均值。将每个数据集都算一次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Spot Check Algorithms</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">models = []</span></pre></td></tr><tr><td class="code"><pre><span class="line">models.append((<span class="string">'LR'</span>, LogisticRegression(solver=<span class="string">'liblinear'</span>, multi_class=<span class="string">'ovr'</span>)))</span></pre></td></tr><tr><td class="code"><pre><span class="line">models.append((<span class="string">'LDA'</span>, LinearDiscriminantAnalysis()))</span></pre></td></tr><tr><td class="code"><pre><span class="line">models.append((<span class="string">'KNN'</span>, KNeighborsClassifier()))</span></pre></td></tr><tr><td class="code"><pre><span class="line">models.append((<span class="string">'CART'</span>, DecisionTreeClassifier()))</span></pre></td></tr><tr><td class="code"><pre><span class="line">models.append((<span class="string">'NB'</span>, GaussianNB()))</span></pre></td></tr><tr><td class="code"><pre><span class="line">models.append((<span class="string">'SVM'</span>, SVC(gamma=<span class="string">'auto'</span>)))</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># evaluate each model in turn</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">results = []</span></pre></td></tr><tr><td class="code"><pre><span class="line">names = []</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name, model <span class="keyword">in</span> models:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(model)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kfold = StratifiedKFold(n_splits=<span class="number">10</span>, random_state=<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">cv_results = cross_val_score(model, X_train, Y_train, cv=kfold, scoring=<span class="string">'accuracy'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># model:通常指数据对象 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># X_train为数据， Y_train为预测数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># cv：交叉验证生成器或可迭代的次数</span></span></pre></td></tr></table></figure>
<p>(3) StratifiedKFold:</p>
<p>StratifiedKFold用法类似Kfold，但是他是分层采样，确保训练集，测试集中<strong>各类别样本**</strong>的比例与原始数据集中相同。**</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kfold = StratifiedKFold(n_splits=<span class="number">10</span>, random_state=<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># n_splits:折叠次数，默认为3，至少为2。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># shuffle:是否在每次分割之前打乱顺序。 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># random_state:随机种子，在shuffle==True时使用，默认使用np.random。</span></span></pre></td></tr></table></figure>
<h2 id="2-metrics-评价指标函数"><a href="#2-metrics-评价指标函数" class="headerlink" title="2 metrics  评价指标函数"></a>2 metrics  评价指标函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span></pre></td></tr></table></figure>
<p>(1) <strong>confusion_matrix</strong>: 混淆矩阵</p>
<p>混淆矩阵的定义:</p>
<ul>
<li>TP(True Positive)：将正类预测为正类数，真实为0，预测也为0</li>
<li>FN(False Negative)：将正类预测为负类数，真实为0，预测为1</li>
<li>FP(False Positive)：将负类预测为正类数， 真实为1，预测为0</li>
<li>TN(True Negative)：将负类预测为负类数，真实为1，预测也为1</li>
</ul>
<p>如果每个类别中的观察数不相等，或者数据集中有两个以上类别，则仅分类精度可能会产生误导。计算混淆矩阵可以使您更好地了解分类模型正确的地方以及产生的错误类型。</p>
<p> <img src="/python%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%8Bsklearn/blog\yunsnow\source\_posts\python学习系列之sklearn\1.png" alt="1" style="zoom: 50%;"></p>
<p>举例: 宠物店有10只动物，其中:狗:6只、猫:4只,若分类后的混淆矩阵如下:</p>
<p><img src="/python%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%8Bsklearn/blog\yunsnow\source\_posts\python学习系列之sklearn\2.png" alt="2" style="zoom:50%;"></p>
<ul>
<li>真实值狗的数量（行数量相加）为6=5+1,分类得到狗的数量（列数量相加）为5=5+0;</li>
<li>真实猫的数量为4=0+4,分类得到猫的数量为5=1+4</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">metrics.confusion_matrix(expected, predicted)<span class="comment"># expected 期望值，predicted 预测值</span></span></pre></td></tr></table></figure>
<p>(2) <strong>accuracy_score</strong>:分类正确的百分比</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">metrics.accuracy_score(y_true, y_pred, normalize=<span class="literal">True</span>, sample_weight=<span class="literal">None</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># y_true 实际值, y_pred预测值, normalize返回值要求（True返回正确的样本占比，false返回的是正确分类的样本数量）</span></span></pre></td></tr></table></figure>
<p>(3) <strong>classification_report</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># y_true 实际值, y_pred预测值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># labels：分类报告中显示的类标签的索引列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># target_names：显示与labels对应的名称</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># digits：指定输出格式的精确度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">metrics.classification_report(y_true, y_pred, labels=<span class="literal">None</span>, target_names=<span class="literal">None</span>, sample_weight=<span class="literal">None</span>, digits=<span class="number">2</span>)</span></pre></td></tr></table></figure>
<p>(4) ROC</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fpr, tpr, thresholds = metrics.roc_curve(y_true,y_score,pos_label=<span class="literal">None</span>,sample_weight=<span class="literal">None</span>, drop_intermediate=<span class="literal">True</span>)</span></pre></td></tr></table></figure>
<p>(5) AUC</p>
]]></content>
  </entry>
  <entry>
    <title>Machine Learning in Pythonstart Machine Learning in Python</title>
    <url>/Machine%20Learning%20in%20Pythonstart%20Machine%20Learning%20in%20Python/</url>
    <content><![CDATA[<p>萌新学习机器学习的相关笔记，从项目上去认识机器学习，熟悉机器学习处理问题的过程，并用python代码实现</p>
<a id="more"></a>
<h2 id="1-机器学习的步骤"><a href="#1-机器学习的步骤" class="headerlink" title="1 机器学习的步骤"></a>1 机器学习的步骤</h2><p>一个机器学习的项目可能不是线性的，但通常分为以下几步:</p>
<ol>
<li>定义问题(问题描述、分类问题还是预测问题等)</li>
<li>数据预处理</li>
<li>算法选择</li>
<li>得出结果</li>
<li>评估结果</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>python学习笔记</title>
    <url>/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>初识python，请多多指教,将遇到的一些问题和知识汇总于此。</p>
<a id="more"></a>
<h2 id="1-for循环的几种写法"><a href="#1-for循环的几种写法" class="headerlink" title="1 for循环的几种写法"></a>1 for循环的几种写法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1 语法格式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="keyword">for</span> variable <span class="keyword">in</span> string |list|tuple|dict|:</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#2 range（[),左闭右开区间）| start :起始值、end:结束值、step:步长</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="keyword">for</span> variable <span class="keyword">in</span> range(start,end,step): </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#3 遍历元组或者列表:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">t_tuple = (<span class="string">'a'</span> ,<span class="string">'b'</span>,<span class="string">'c'</span>)  <span class="comment">#or t_tuple = [1,'a' ,'b','c']</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> t_tuple: <span class="comment"># or for t int range(0,len(t_tuple))</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(t_tuple(t))<span class="comment"># print(t_tuple[t])</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">## 4 遍历字典 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># dict三种方法：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#   items(): 返回字典中所有 key-value 的列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#   keys():key列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#   values():value列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#  	example: dict_test = &#123;'张三': 20, '李四': 30, 'x': 23&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 	dict_test.items() : dict_items([('张三', 20), ('李四', 30), ('x', 23)])</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 	dict_test.keys() :  dict_keys(['张三', '李四', 'x'])</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 	dict_test.values() :  dict_values([20, 30, 23])</span></span></pre></td></tr></table></figure>
<h2 id="2-类的定义和使用"><a href="#2-类的定义和使用" class="headerlink" title="2 类的定义和使用"></a>2 类的定义和使用</h2><p>​    （1）定义类:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Student</span><span class="params">(Object)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># __init__的第一个参数永远是self(约定俗成的词,也可以为其他(myname...))</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># ***self表示类实例本身,调用时不需要传入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.name = name</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.age = age</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># (private)私有变量的定义方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.__name = name</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.__age = age</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 内部定义的函数可以通过self直接获取类实例本身的数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_age</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        print(self.name.self.age)</span></pre></td></tr><tr><td class="code"><pre><span class="line">stu = Student(<span class="string">'yunsnow'</span>,<span class="number">24</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">stu.name <span class="comment"># yunsnow</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">stu.age <span class="comment"># 24</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">stu.__name <span class="comment"># AttributeError: 'Student' object has no attribute '__name'</span></span></pre></td></tr></table></figure>
<h2 id="3-python内置数据结构"><a href="#3-python内置数据结构" class="headerlink" title="3 python内置数据结构"></a>3 python内置数据结构</h2><p>​    常用的有五种：<strong>列表</strong>(list)、<strong>元组</strong>(tuple)、<strong>字符串</strong>(str)、集合(set)和<strong>字典</strong>(dict)</p>
<ol>
<li><p>列表 ：<strong>有序的，通过索引找值</strong>。<strong><em>中括号[]表示</em></strong>, 如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># list中可以有其他数据结构</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="string">'x'</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 增</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">a.append(<span class="string">'y'</span>) <span class="comment"># a  = [1, 2, 'x', [1, 2, 3], 'y']</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 删</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">a.remove(<span class="string">'y'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 改</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">a[<span class="number">1</span>] = <span class="string">'a'</span> <span class="comment"># a = [1, 'a', 'x', [1, 2, 3]]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>:<span class="number">2</span>] = [<span class="number">2</span>,<span class="number">3</span>] <span class="comment"># a =[2, 3, 4, 'x', [1, 2, 3]]</span></span></pre></td></tr></table></figure>
</li>
<li><p>字典： <strong><em>大括号{}表示</em></strong>，key :  value,key不能重复、value可以修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">student=&#123;<span class="string">'name'</span>:<span class="string">'yunsnow'</span>,<span class="string">'age'</span>:<span class="number">24</span>,<span class="string">'sex'</span>:<span class="string">'man'</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 增</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">student[<span class="string">'grade'</span>] = <span class="string">'excellent'</span> <span class="comment"># or student.update(&#123;'grade':'excellent'&#125;)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(student) <span class="comment"># &#123;'name': 'yunsnow', 'age': 24, 'sex': 'man', 'grade': 'excellent'&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 删</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> student[<span class="string">'grade'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 改(只能修改value，key不可修改)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">student[<span class="string">'age'</span>]=<span class="number">25</span> <span class="comment"># &#123;'name': 'yunsnow', 'age': 25, 'sex': 'man'&#125;</span></span></pre></td></tr></table></figure>
</li>
<li><p>tuple:<strong><em>小括号()表示</em></strong>,元素不可修改，只能查看</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list_name = [<span class="string">'yunsnow'</span>,<span class="string">'zhu'</span>,<span class="string">'ren'</span>,<span class="string">'yunsnow'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">set = set(list_name)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> (set) <span class="comment"># &#123;'yunsnow', 'zhu', 'ren'&#125;</span></span></pre></td></tr></table></figure>
<h3 id="4-matplotlib-绘图工具"><a href="#4-matplotlib-绘图工具" class="headerlink" title="4  matplotlib 绘图工具"></a>4  matplotlib 绘图工具</h3><p>(1)坐标轴刻度的选择，以设置时间为例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需求：横坐标显示9:00-19:00时间，刻度为每隔两小时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">date_list = [] <span class="comment"># 存放时间数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">time_begin = <span class="string">'9:00'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">d = datetime.datetime.strptime(time_begin, <span class="string">'%H:%M'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">p = <span class="number">15</span> <span class="comment"># 时间间隔，15Min</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">date_point = <span class="number">44</span> <span class="comment"># 时间点，10个小时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">date_list.append(d)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, date_point):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#  datetime.timedelta增减时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    date_list.append(date_list[i - <span class="number">1</span>] + datetime.timedelta(minutes=<span class="number">15</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, date_point):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    date_list[i] = date_list[i].strftime(<span class="string">'%H:%M'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">y = np.random.randint(<span class="number">0</span>,<span class="number">10</span>,[date_point,<span class="number">1</span>])<span class="comment"># 随机生成数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ax=plt.gca() <span class="comment"># ax为两条坐标轴的实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">x_major_locator=MultipleLocator(<span class="number">8</span>) <span class="comment"># 设置刻度间隔，这里设为8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ax.xaxis.set_major_locator(x_major_locator)<span class="comment">#</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.plot(date_list, y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr></table></figure>
<p><img src="/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" style="zoom:50%;"></p>
]]></content>
  </entry>
  <entry>
    <title>推荐系统学习笔记</title>
    <url>/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>基于个性化广告推荐系统的需求，学习相关推荐系统知识</p>
<a id="more"></a>
<h2 id="1-个性化广告的概念"><a href="#1-个性化广告的概念" class="headerlink" title="1  个性化广告的概念"></a>1  个性化广告的概念</h2><p>​        广告是互联网公司生存的根本，目前，很多广告都是随机投放的，即每次用户来了，随机选择一个广告投放给他。  个性化广告投放目前已经成为了一门独立的学科——计算广告学——但该学科和推荐系统在很多基础理论和方法上是相通的，比如它们的目的都是联系用户和物品，只是在个性化广告中，<strong>物品就是广告</strong>。</p>
<p>​        广告投放技术分为3类：    </p>
<ul>
<li><strong>上下文广告</strong>  通过分析用户正在浏览的网页内容，投放和网页内容相关的广告。代表系统是谷歌的Adsense。</li>
<li><strong>搜索广告</strong>  通过分析用户在当前会话中的搜索记录，判断用户的搜索目的，投放和用户目的相关的广告。</li>
<li><strong>个性化展示广告</strong>  我们经常在很多网站看到大量展示广告（就是那些大的横幅图片），它们是根据用户的兴趣，对不同用户投放不同的展示广告。雅虎是这方面研究的代表  </li>
</ul>
<h2 id="2-推荐系统的优点和好处"><a href="#2-推荐系统的优点和好处" class="headerlink" title="2  推荐系统的优点和好处"></a>2  推荐系统的优点和好处</h2><p>​        可帮助用户在大信息中找到自己喜欢的内容。如淘宝的猜你喜欢，抖音个性化视频推荐。</p>
<h2 id="3-推荐系统的术语"><a href="#3-推荐系统的术语" class="headerlink" title="3  推荐系统的术语"></a>3  推荐系统的术语</h2><ul>
<li>(1) <strong>条目</strong>： 推荐系统实体，淘宝的实体为用户购买的商品，抖音的实体就是视频</li>
<li>(2) <strong>查询</strong>：推荐系统给出推荐内容的来源，可以是以下三种的组合<ul>
<li><strong>用户信息</strong>：用户的ID，用户先前与之产生交互的条目</li>
<li><strong>上下文信息</strong>：一天中的时间，用户的设备</li>
<li><strong>条目信息</strong>：商品名称，商品类别</li>
</ul>
</li>
<li>(3) <strong>嵌入(Embedding)</strong>: 离散集合(查询集或推荐条目)==&gt;嵌入空间的映射。</li>
</ul>
<h2 id="4-推荐系统架构"><a href="#4-推荐系统架构" class="headerlink" title="4 **推荐系统架构"></a>4 **推荐系统架构</h2><p>​        推荐系统体系架构分成三部分: <strong>召回、打分、重排</strong></p>
<h3 id="4-1-召回-笼统排序"><a href="#4-1-召回-笼统排序" class="headerlink" title="4.1  召回(笼统排序)"></a>4.1  召回(笼统排序)</h3><p>​        即从众多信息中生成候选集合。如抖音从几十亿视频选出一千个。此过程需要快速查询。</p>
<p>​        方法：给定模型可有多个召回队列，每个队列都筛选不同类型的候选子集。</p>
<h4 id="4-1-1-召回方法："><a href="#4-1-1-召回方法：" class="headerlink" title="4.1.1 召回方法："></a>4.1.1 召回方法：</h4><ul>
<li>​        基于内容的过滤：</li>
<li>​        协同过滤：</li>
<li>​        基于神经网络方法：    </li>
</ul>
<h3 id="4-2-计分-精细排序"><a href="#4-2-计分-精细排序" class="headerlink" title="4.2  计分(精细排序)"></a>4.2  计分(精细排序)</h3><p>​        另一个模型对候选集进行评分和排序，以选择要显示给用户的集合（大约10个）。由于此模型评估的是商品的相对较小子集，因此系统可以依靠其他信息来使用更精确的模型。</p>
<h3 id="4-3-重排"><a href="#4-3-重排" class="headerlink" title="4.3  重排"></a>4.3  重排</h3><p>​        最后，系统必须考虑最终排名的其他限制。例如，系统删除用户明确不喜欢的项目或提高时效内容的得分。重新排序还可以帮助确保多样性，时效性和公平性。</p>
<h2 id="5-推荐系统实验方法"><a href="#5-推荐系统实验方法" class="headerlink" title="5  推荐系统实验方法"></a>5  推荐系统实验方法</h2><p>​        推荐系统主要有3种评测推荐效果的实验方法，即<strong>离线实验</strong>（ offline experiment）、<strong>用户调查</strong>（ user study）和<strong>在线实验</strong>（ online experiment）  </p>
<h3 id="5-1-离线试验"><a href="#5-1-离线试验" class="headerlink" title="5.1  离线试验"></a>5.1  离线试验</h3><pre><code>      离线实验的方法一般由如下几个步骤构成：
    (1) 通过日志系统获得用户行为数据，并按照一定格式生成一个标准的数据集
    (2) 将数据集按照一定的规则分成训练集和测试集；
    (3) 在训练集上训练用户兴趣模型，在测试集上进行预测；
    (4) 通过事先定义的离线指标评测算法在测试集上的预测结果。  
</code></pre><p><center>表1 离线实验的优缺点</center><br>|                     优点                     |               缺点               |<br>| :—————————————————————: | :———————————————: |<br>|          不需要有对实际系统的控制权          |     无法计算商业上关心的指标     |<br>| 不需要用户参与实验、速度快，可以测试大量算法 | 离线实验的指标和商业指标存在差距 |</p>
<h3 id="5-2-用户调查"><a href="#5-2-用户调查" class="headerlink" title="5.2  用户调查"></a>5.2  用户调查</h3><p>​        用户调查需要有一些真实用户，让他们在需要测试的推荐系统上完成一些任务。在他们完成任务时，我们需要观察和记录他们的行为，并让他们回答一些问题。最后，我们需要通过分析他们的行为和答案了解测试系统的性能。</p>
<p>​        用户调查的优缺点也很明显。它的<strong>优点</strong>是可以获得很多体现用户主观感受的指标，相对在线实验风险很低，出现错误后很容易弥补。<strong>缺点</strong>是招募测试用户代价较大，很难组织大规模的测试用户，因此会使测试结果的统计意义不足。此外，在很多时候设计双盲实验非常困难，而且用户在测试环境下的行为和真实环境下的行为可能有所不同，因而在测试环境下收集的测试指标可能在真实环境下无法重现。</p>
<h3 id="5-3-在线实验"><a href="#5-3-在线实验" class="headerlink" title="5.3 在线实验"></a>5.3 在线实验</h3><p>将推荐系统上线做AB测试，将它和旧的算法进行比较 。</p>
<p>本文参考以下内容：<a href="https://zhuanlan.zhihu.com/p/87578318" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/87578318</a></p>
]]></content>
  </entry>
  <entry>
    <title>typora使用手册</title>
    <url>/typora%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>记录使用Typora编写markdown语法过程中一些实用技巧。</p>
<a id="more"></a>
<h2 id="1-快捷键："><a href="#1-快捷键：" class="headerlink" title="1 快捷键："></a>1 快捷键：</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Ctrl+1</td>
<td style="text-align:center">一阶标题</td>
<td style="text-align:center">Ctrl+B</td>
<td style="text-align:center">字体加粗</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+2</td>
<td style="text-align:center">二阶标题</td>
<td style="text-align:center">Ctrl+I</td>
<td style="text-align:center">字体倾斜</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+3</td>
<td style="text-align:center">三阶标题</td>
<td style="text-align:center">Ctrl+U</td>
<td style="text-align:center">下划线</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+4</td>
<td style="text-align:center">四阶标题</td>
<td style="text-align:center">Ctrl+Home</td>
<td style="text-align:center">返回Typora顶部</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+5</td>
<td style="text-align:center">五阶标题</td>
<td style="text-align:center">Ctrl+End</td>
<td style="text-align:center">返回Typora底部</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+6</td>
<td style="text-align:center">六阶标题</td>
<td style="text-align:center">Ctrl+T</td>
<td style="text-align:center">创建表格</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+L</td>
<td style="text-align:center">选中某句话</td>
<td style="text-align:center">Ctrl+K</td>
<td style="text-align:center">创建超链接</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+D</td>
<td style="text-align:center">选中某个单词</td>
<td style="text-align:center">Ctrl+F</td>
<td style="text-align:center">搜索</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+E</td>
<td style="text-align:center">选中相同格式的文字</td>
<td style="text-align:center">Ctrl+H</td>
<td style="text-align:center">搜索并替换</td>
</tr>
<tr>
<td style="text-align:center">Alt+Shift+5</td>
<td style="text-align:center">删除线</td>
<td style="text-align:center">Ctrl+Shift+I</td>
<td style="text-align:center">插入图片</td>
</tr>
</tbody>
</table>
</div>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
