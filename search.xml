<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>test</title>
    <url>/test/</url>
    <content><![CDATA[<p><img src="/test/t1.jpg" alt></p>
]]></content>
  </entry>
  <entry>
    <title>毕业论文学习系列之ECG信号处理</title>
    <url>/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%8BECG%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>该篇文章主要记录撰写毕业论文的过程中对ECG信号处理过程中遇到的问题和知识盲点的总结</p>
<a id="more"></a>
<h2 id="一-单位转换"><a href="#一-单位转换" class="headerlink" title="一 单位转换"></a>一 单位转换</h2><p>频率：f=1/T,T为周期,如1ms = 0.001s, f = 1/0.001=1000Hz 所以 1ms =1000HZ</p>
<p>实验采用AD8232评估板与3引脚ECG监视器配合使用来获取ECG信号，采样率为192HZ,即5.2ms为一拍</p>
<p>其中90％以上的ECG信号能量集中在<strong>0.25Hz～35Hz</strong>之间</p>
<h2 id="二-傅里叶变换"><a href="#二-傅里叶变换" class="headerlink" title="二 傅里叶变换"></a>二 傅里叶变换</h2><ol>
<li><p>时域和频域的理解:    </p>
<p>时域:以<strong>时间作为参照来</strong>观察动态世界的方法我们称其为时域分析</p>
<p>频域:它<strong>不是真实</strong>的，而是一个数学构造。时域是<strong>惟一客观存在的域</strong>，而<strong>频域是一个遵循特定规则的数学范畴</strong>，频域也被一些学者称为上帝视角</p>
</li>
<li><p>傅里叶变换的实质：<strong>频域函数和时域函数</strong>的转换，其中<strong>时域</strong>就是永远<strong>随着时间的变化而变化</strong>的，而<strong>频域</strong>就是<strong>装着装着正余弦波的空间</strong></p>
</li>
</ol>
<h2 id="三-滤波器"><a href="#三-滤波器" class="headerlink" title="三  滤波器"></a>三  滤波器</h2><p>滤波器是一种选频装置，可以使信号中<strong>特定的频率成分</strong>通过，而极大地衰减其他频率成分。利用滤波器的这种选频作用，可以<strong>滤除干扰噪声或进行频谱分析</strong></p>
<p>概念: 滤波器是对<strong>波进行过滤</strong>的器件，是一种让<strong>某一频带内信号通过</strong>，同时又<strong>阻止这一频带外信号通过的电路</strong>。</p>
<h3 id="1-滤波器的作用："><a href="#1-滤波器的作用：" class="headerlink" title="1  滤波器的作用："></a>1  滤波器的作用：</h3><ul>
<li>1、将有用的信号与噪声分离，提高信号的抗干扰性及信噪比；</li>
<li>2、滤掉不感兴趣的频率成分，提高分析精度；</li>
<li>3、从复杂频率成分中分离出单一的频率分量</li>
</ul>
<h3 id="2-滤波器的分类"><a href="#2-滤波器的分类" class="headerlink" title="2  滤波器的分类:"></a>2  滤波器的分类:</h3><ul>
<li><p>低通滤波器(LPF)：</p>
<p>从<strong>0～f2</strong>频率之间，幅频特性平直，它可以使<strong>信号中低于f2的频率</strong>成分几乎不受衰减地通过，而高于f2的频率成分受到极大地衰减</p>
</li>
<li><p>高通滤波器(HPF)</p>
<p>与低通滤波相反，从<strong>频率f1～∞</strong>，其幅频特性平直。它使信号中<strong>高于f1的频率</strong>成分几乎不受衰减地<strong>通过</strong>，而<strong>低于f1</strong>的频率成分将受到<strong>极大地衰减</strong></p>
</li>
<li><p>带通滤波器(BHF)</p>
<p>它的通频带在f1～f2之间。它使信号中<strong>高于f1而低于f2的频率</strong>成分可以不受衰减地通过，而其它成分受到衰减。</p>
</li>
<li><p>带阻滤波器</p>
<p>与带通滤波相反，阻带在频率f1～f2之间。它使信号中<strong>高于f1而低于f2的频率成分受到衰减</strong>，其余频率成分的信号几乎不受衰减地通过</p>
</li>
</ul>
<h3 id="3-matlab-Butter-函数使用"><a href="#3-matlab-Butter-函数使用" class="headerlink" title="3 matlab Butter()函数使用"></a>3 matlab Butter()函数使用</h3><p>Butterworth滤波器，使用方法</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[B,A] = BUTTER(N,Wn,<span class="string">'high'</span>) <span class="comment">% 用来设计高通滤波器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[B,A] = BUTTER(N,Wn,<span class="string">'low'</span>) <span class="comment">% designs a lowpass filter.--低通滤波器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[B,A] = BUTTER(N,Wn)<span class="comment">% 带通滤波器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">% 其中，Wn = [a,b],若采样率为192HZ,设计一个3阶，通带为0.04-20HZ的带通滤波器:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">[b,a] = butter(<span class="number">3</span>,[<span class="number">0.02</span>/(<span class="number">192</span>/<span class="number">2</span>) <span class="number">20</span>/(<span class="number">192</span>/<span class="number">2</span>)])</span></pre></td></tr></table></figure>
<h2 id="四-ECG信号HRV分析"><a href="#四-ECG信号HRV分析" class="headerlink" title="四 ECG信号HRV分析"></a>四 ECG信号HRV分析</h2><p>心率变异性(Heart Rate Variability ,HRV)是指逐次心搏间期之间的微小变异特性。HRV分析可作为预测心梗死亡率的指标及预测末期肝病患的预后。</p>
<h3 id="1-HRV周期频率"><a href="#1-HRV周期频率" class="headerlink" title="1 HRV周期频率"></a>1 HRV周期频率</h3><p>HRV周期频率通过时频域变换可分为三分频段:</p>
<ul>
<li><strong>VLF</strong>:超低频（&lt;0.04Hz)  <strong>可能与体温调节及心率中缓慢的变化趋势有关</strong>  </li>
<li><strong>LF</strong>:低频段（0.04-0.15Hz）  <strong>反映心脏交感神经的活性</strong>  </li>
<li><strong>HF</strong>:高频段（0.15-0.4Hz）  <strong>反映心脏迷走神经的活性</strong>  </li>
</ul>
<h3 id="2-ECG信号特征"><a href="#2-ECG信号特征" class="headerlink" title="2 ECG信号特征"></a>2 ECG信号特征</h3><p>每个心动周期的正常心电信号波形中包含一个<strong>P波</strong>，一个<strong>QRS波</strong>、一个<strong>T波</strong>和U波，如下图所示:</p>
<p><img src="/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%8BECG%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/1.jpg" alt></p>
<ul>
<li>P波:左右心房的初级过程引起，波型小，时宽:0.08s-0.11s,波幅&lt;0.25mV</li>
<li>QRS波:P波出现之后，典型的QRS波包括:第一个向下的Q波，第二个尖尖向上的<strong>R波</strong>，最后一个向下的S波<ul>
<li>正常QRS间期为0.01~0.1s,如大于0.12s，则反映室内传导阻滞</li>
</ul>
</li>
<li>T波:代表心室复极的电位变化，与R波方向相同，时宽0.05~0.25s,波幅0.1mV~0.8mV</li>
</ul>
<p>RR 间期：相邻 QRS 波群之间的间距称为 RR 间期，反映心室率。正常情况下，RR间期与 PP 间期一致。 </p>
<h3 id="3-HRV时域分析"><a href="#3-HRV时域分析" class="headerlink" title="3 HRV时域分析"></a>3 HRV时域分析</h3><p>HRV时域分析主要指标:</p>
<p><img src="/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%8BECG%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/2.png" alt></p>
<p>HRV频域分析主要指标：</p>
<p><img src="/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%8BECG%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/3.png" alt></p>
<p>本文内容参考文献：<a href="https://blog.csdn.net/qq_41736609/article/details/79710779" target="_blank" rel="noopener">https://blog.csdn.net/qq_41736609/article/details/79710779</a></p>
<p>​                                <a href="https://www.cnblogs.com/h2zZhou/p/8405717.html" target="_blank" rel="noopener">https://www.cnblogs.com/h2zZhou/p/8405717.html</a></p>
<p>​                                <a href="https://wenku.baidu.com/view/443a758cce84b9d528ea81c758f5f61fb73628bb.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/443a758cce84b9d528ea81c758f5f61fb73628bb.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>python学习系列之sklearn</title>
    <url>/python%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%8Bsklearn/</url>
    <content><![CDATA[<p>2sklearn中相关api的使用</p>
<a id="more"></a>
<h2 id="1-model-selection"><a href="#1-model-selection" class="headerlink" title="1 model_selection"></a>1 model_selection</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> model_selection</span></pre></td></tr></table></figure>
<p>sklearn.model_selection中的相关api</p>
<p>(1) <strong>train_test_split</strong> : 矩阵随机划分测试集和训练集合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train, X_validation, Y_train, Y_validation = train_test_split(X, y, test_size=<span class="number">0.20</span>, random_state=<span class="number">1</span>, shuffle=<span class="literal">True</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># x_train、X_validation为训练特征文本数据;Y_train, Y_validation 为标签数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># test_size:样本占比，测试集占数据集的比重，如果是整数的话就是样本的数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># random_state :给定random_state后，每次构建的模型是相同的、生成的数据集是相同的、每次的拆分结果也是相同的。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># shuffle:是否打乱数据顺序</span></span></pre></td></tr></table></figure>
<p>(2) cross_val_score:交叉验证</p>
<p>以例子说明含义:若将数据集分为10折，做一次交叉验证，实际上它是计算了十次，将每一折都当做一次测试集，其余九折当做训练集，这样循环十次。通过传入的模型，训练十次，最后将十次结果求平均值。将每个数据集都算一次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Spot Check Algorithms</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">models = []</span></pre></td></tr><tr><td class="code"><pre><span class="line">models.append((<span class="string">'LR'</span>, LogisticRegression(solver=<span class="string">'liblinear'</span>, multi_class=<span class="string">'ovr'</span>)))</span></pre></td></tr><tr><td class="code"><pre><span class="line">models.append((<span class="string">'LDA'</span>, LinearDiscriminantAnalysis()))</span></pre></td></tr><tr><td class="code"><pre><span class="line">models.append((<span class="string">'KNN'</span>, KNeighborsClassifier()))</span></pre></td></tr><tr><td class="code"><pre><span class="line">models.append((<span class="string">'CART'</span>, DecisionTreeClassifier()))</span></pre></td></tr><tr><td class="code"><pre><span class="line">models.append((<span class="string">'NB'</span>, GaussianNB()))</span></pre></td></tr><tr><td class="code"><pre><span class="line">models.append((<span class="string">'SVM'</span>, SVC(gamma=<span class="string">'auto'</span>)))</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># evaluate each model in turn</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">results = []</span></pre></td></tr><tr><td class="code"><pre><span class="line">names = []</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name, model <span class="keyword">in</span> models:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(model)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kfold = StratifiedKFold(n_splits=<span class="number">10</span>, random_state=<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">cv_results = cross_val_score(model, X_train, Y_train, cv=kfold, scoring=<span class="string">'accuracy'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># model:通常指数据对象 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># X_train为数据， Y_train为预测数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># cv：交叉验证生成器或可迭代的次数</span></span></pre></td></tr></table></figure>
<p>(3) StratifiedKFold:</p>
<p>StratifiedKFold用法类似Kfold，但是他是分层采样，确保训练集，测试集中<strong>各类别样本**</strong>的比例与原始数据集中相同。**</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kfold = StratifiedKFold(n_splits=<span class="number">10</span>, random_state=<span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># n_splits:折叠次数，默认为3，至少为2。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># shuffle:是否在每次分割之前打乱顺序。 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># random_state:随机种子，在shuffle==True时使用，默认使用np.random。</span></span></pre></td></tr></table></figure>
<h2 id="2-metrics-评价指标函数"><a href="#2-metrics-评价指标函数" class="headerlink" title="2 metrics  评价指标函数"></a>2 metrics  评价指标函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span></pre></td></tr></table></figure>
<p>(1) <strong>confusion_matrix</strong>: 混淆矩阵</p>
<p>混淆矩阵的定义:</p>
<ul>
<li>TP(True Positive)：将正类预测为正类数，真实为0，预测也为0</li>
<li>FN(False Negative)：将正类预测为负类数，真实为0，预测为1</li>
<li>FP(False Positive)：将负类预测为正类数， 真实为1，预测为0</li>
<li>TN(True Negative)：将负类预测为负类数，真实为1，预测也为1</li>
</ul>
<p>如果每个类别中的观察数不相等，或者数据集中有两个以上类别，则仅分类精度可能会产生误导。计算混淆矩阵可以使您更好地了解分类模型正确的地方以及产生的错误类型。</p>
<p><img src="/python%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%8Bsklearn/Users\57266\AppData\Roaming\Typora\typora-user-images\image-20200113152040126.png" alt="image-20200113152040126" style="zoom: 50%;"> </p>
<p>举例: 宠物店有10只动物，其中:狗:6只、猫:4只,若分类后的混淆矩阵如下:</p>
<p><img src="/python%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E4%B9%8Bsklearn/Users\57266\AppData\Roaming\Typora\typora-user-images\image-20200113152418635.png" alt="image-20200113152418635" style="zoom:50%;"></p>
<ul>
<li>真实值狗的数量（行数量相加）为6=5+1,分类得到狗的数量（列数量相加）为5=5+0;</li>
<li>真实猫的数量为4=0+4,分类得到猫的数量为5=1+4</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">metrics.confusion_matrix(expected, predicted)<span class="comment"># expected 期望值，predicted 预测值</span></span></pre></td></tr></table></figure>
<p>(2) <strong>accuracy_score</strong>:分类正确的百分比</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">metrics.accuracy_score(y_true, y_pred, normalize=<span class="literal">True</span>, sample_weight=<span class="literal">None</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># y_true 实际值, y_pred预测值, normalize返回值要求（True返回正确的样本占比，false返回的是正确分类的样本数量）</span></span></pre></td></tr></table></figure>
<p>(3) <strong>classification_report</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># y_true 实际值, y_pred预测值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># labels：分类报告中显示的类标签的索引列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># target_names：显示与labels对应的名称</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># digits：指定输出格式的精确度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">metrics.classification_report(y_true, y_pred, labels=<span class="literal">None</span>, target_names=<span class="literal">None</span>, sample_weight=<span class="literal">None</span>, digits=<span class="number">2</span>)</span></pre></td></tr></table></figure>
<p>(4) ROC</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fpr, tpr, thresholds = metrics.roc_curve(y_true,y_score,pos_label=<span class="literal">None</span>,sample_weight=<span class="literal">None</span>, drop_intermediate=<span class="literal">True</span>)</span></pre></td></tr></table></figure>
<p>(5) AUC</p>
]]></content>
  </entry>
  <entry>
    <title>Machine Learning in Pythonstart Machine Learning in Python</title>
    <url>/Machine%20Learning%20in%20Pythonstart%20Machine%20Learning%20in%20Python/</url>
    <content><![CDATA[<p>萌新学习机器学习的相关笔记，从项目上去认识机器学习，熟悉机器学习处理问题的过程，并用python代码实现</p>
<a id="more"></a>
<h2 id="1-机器学习的步骤"><a href="#1-机器学习的步骤" class="headerlink" title="1 机器学习的步骤"></a>1 机器学习的步骤</h2><p>一个机器学习的项目可能不是线性的，但通常分为以下几步:</p>
<ol>
<li>定义问题(问题描述、分类问题还是预测问题等)</li>
<li>数据预处理</li>
<li>算法选择</li>
<li>得出结果</li>
<li>评估结果</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>python学习笔记</title>
    <url>/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>初识python，请多多指教,将遇到的一些问题和知识汇总于此。</p>
<a id="more"></a>
<h2 id="1-for循环的几种写法"><a href="#1-for循环的几种写法" class="headerlink" title="1 for循环的几种写法"></a>1 for循环的几种写法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1 语法格式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="keyword">for</span> variable <span class="keyword">in</span> string |list|tuple|dict|:</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#2 range（[),左闭右开区间）| start :起始值、end:结束值、step:步长</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> <span class="keyword">for</span> variable <span class="keyword">in</span> range(start,end,step): </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#3 遍历元组或者列表:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">t_tuple = (<span class="string">'a'</span> ,<span class="string">'b'</span>,<span class="string">'c'</span>)  <span class="comment">#or t_tuple = [1,'a' ,'b','c']</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> t_tuple: <span class="comment"># or for t int range(0,len(t_tuple))</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(t_tuple(t))<span class="comment"># print(t_tuple[t])</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">## 4 遍历字典 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># dict三种方法：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#   items(): 返回字典中所有 key-value 的列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#   keys():key列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#   values():value列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#  	example: dict_test = &#123;'张三': 20, '李四': 30, 'x': 23&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 	dict_test.items() : dict_items([('张三', 20), ('李四', 30), ('x', 23)])</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 	dict_test.keys() :  dict_keys(['张三', '李四', 'x'])</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 	dict_test.values() :  dict_values([20, 30, 23])</span></span></pre></td></tr></table></figure>
<h2 id="2-类的定义和使用"><a href="#2-类的定义和使用" class="headerlink" title="2 类的定义和使用"></a>2 类的定义和使用</h2><p>​    （1）定义类:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Student</span><span class="params">(Object)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># __init__的第一个参数永远是self(约定俗成的词,也可以为其他(myname...))</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># ***self表示类实例本身,调用时不需要传入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.name = name</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.age = age</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment"># (private)私有变量的定义方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.__name = name</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.__age = age</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># 内部定义的函数可以通过self直接获取类实例本身的数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_age</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        print(self.name.self.age)</span></pre></td></tr><tr><td class="code"><pre><span class="line">stu = Student(<span class="string">'yunsnow'</span>,<span class="number">24</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">stu.name <span class="comment"># yunsnow</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">stu.age <span class="comment"># 24</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">stu.__name <span class="comment"># AttributeError: 'Student' object has no attribute '__name'</span></span></pre></td></tr></table></figure>
<h2 id="3-python内置数据结构"><a href="#3-python内置数据结构" class="headerlink" title="3 python内置数据结构"></a>3 python内置数据结构</h2><p>​    常用的有五种：<strong>列表</strong>(list)、<strong>元组</strong>(tuple)、<strong>字符串</strong>(str)、集合(set)和<strong>字典</strong>(dict)</p>
<ol>
<li><p>列表 ：<strong>有序的，通过索引找值</strong>。<strong><em>中括号[]表示</em></strong>, 如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># list中可以有其他数据结构</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="string">'x'</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 增</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">a.append(<span class="string">'y'</span>) <span class="comment"># a  = [1, 2, 'x', [1, 2, 3], 'y']</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 删</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">a.remove(<span class="string">'y'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 改</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">a[<span class="number">1</span>] = <span class="string">'a'</span> <span class="comment"># a = [1, 'a', 'x', [1, 2, 3]]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>:<span class="number">2</span>] = [<span class="number">2</span>,<span class="number">3</span>] <span class="comment"># a =[2, 3, 4, 'x', [1, 2, 3]]</span></span></pre></td></tr></table></figure>
</li>
<li><p>字典： <strong><em>大括号{}表示</em></strong>，key :  value,key不能重复、value可以修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">student=&#123;<span class="string">'name'</span>:<span class="string">'yunsnow'</span>,<span class="string">'age'</span>:<span class="number">24</span>,<span class="string">'sex'</span>:<span class="string">'man'</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 增</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">student[<span class="string">'grade'</span>] = <span class="string">'excellent'</span> <span class="comment"># or student.update(&#123;'grade':'excellent'&#125;)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(student) <span class="comment"># &#123;'name': 'yunsnow', 'age': 24, 'sex': 'man', 'grade': 'excellent'&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 删</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> student[<span class="string">'grade'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># 改(只能修改value，key不可修改)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">student[<span class="string">'age'</span>]=<span class="number">25</span> <span class="comment"># &#123;'name': 'yunsnow', 'age': 25, 'sex': 'man'&#125;</span></span></pre></td></tr></table></figure>
</li>
<li><p>tuple:<strong><em>小括号()表示</em></strong>,元素不可修改，只能查看</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list_name = [<span class="string">'yunsnow'</span>,<span class="string">'zhu'</span>,<span class="string">'ren'</span>,<span class="string">'yunsnow'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">set = set(list_name)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> (set) <span class="comment"># &#123;'yunsnow', 'zhu', 'ren'&#125;</span></span></pre></td></tr></table></figure>
<h3 id="4-matplotlib-绘图工具"><a href="#4-matplotlib-绘图工具" class="headerlink" title="4  matplotlib 绘图工具"></a>4  matplotlib 绘图工具</h3><p>(1)坐标轴刻度的选择，以设置时间为例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需求：横坐标显示9:00-19:00时间，刻度为每隔两小时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">date_list = [] <span class="comment"># 存放时间数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">time_begin = <span class="string">'9:00'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">d = datetime.datetime.strptime(time_begin, <span class="string">'%H:%M'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">p = <span class="number">15</span> <span class="comment"># 时间间隔，15Min</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">date_point = <span class="number">44</span> <span class="comment"># 时间点，10个小时</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">date_list.append(d)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, date_point):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#  datetime.timedelta增减时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    date_list.append(date_list[i - <span class="number">1</span>] + datetime.timedelta(minutes=<span class="number">15</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, date_point):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    date_list[i] = date_list[i].strftime(<span class="string">'%H:%M'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">y = np.random.randint(<span class="number">0</span>,<span class="number">10</span>,[date_point,<span class="number">1</span>])<span class="comment"># 随机生成数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ax=plt.gca() <span class="comment"># ax为两条坐标轴的实例</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">x_major_locator=MultipleLocator(<span class="number">8</span>) <span class="comment"># 设置刻度间隔，这里设为8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ax.xaxis.set_major_locator(x_major_locator)<span class="comment">#</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.plot(date_list, y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr></table></figure>
<p><img src="/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png" style="zoom:50%;"></p>
]]></content>
  </entry>
  <entry>
    <title>推荐系统学习笔记</title>
    <url>/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>基于个性化广告推荐系统的需求，学习相关推荐系统知识</p>
<a id="more"></a>
<h2 id="1-个性化广告的概念"><a href="#1-个性化广告的概念" class="headerlink" title="1  个性化广告的概念"></a>1  个性化广告的概念</h2><p>​        广告是互联网公司生存的根本，目前，很多广告都是随机投放的，即每次用户来了，随机选择一个广告投放给他。  个性化广告投放目前已经成为了一门独立的学科——计算广告学——但该学科和推荐系统在很多基础理论和方法上是相通的，比如它们的目的都是联系用户和物品，只是在个性化广告中，<strong>物品就是广告</strong>。</p>
<p>​        广告投放技术分为3类：    </p>
<ul>
<li><strong>上下文广告</strong>  通过分析用户正在浏览的网页内容，投放和网页内容相关的广告。代表系统是谷歌的Adsense。</li>
<li><strong>搜索广告</strong>  通过分析用户在当前会话中的搜索记录，判断用户的搜索目的，投放和用户目的相关的广告。</li>
<li><strong>个性化展示广告</strong>  我们经常在很多网站看到大量展示广告（就是那些大的横幅图片），它们是根据用户的兴趣，对不同用户投放不同的展示广告。雅虎是这方面研究的代表  </li>
</ul>
<h2 id="2-推荐系统的优点和好处"><a href="#2-推荐系统的优点和好处" class="headerlink" title="2  推荐系统的优点和好处"></a>2  推荐系统的优点和好处</h2><p>​        可帮助用户在大信息中找到自己喜欢的内容。如淘宝的猜你喜欢，抖音个性化视频推荐。</p>
<h2 id="3-推荐系统的术语"><a href="#3-推荐系统的术语" class="headerlink" title="3  推荐系统的术语"></a>3  推荐系统的术语</h2><ul>
<li>(1) <strong>条目</strong>： 推荐系统实体，淘宝的实体为用户购买的商品，抖音的实体就是视频</li>
<li>(2) <strong>查询</strong>：推荐系统给出推荐内容的来源，可以是以下三种的组合<ul>
<li><strong>用户信息</strong>：用户的ID，用户先前与之产生交互的条目</li>
<li><strong>上下文信息</strong>：一天中的时间，用户的设备</li>
<li><strong>条目信息</strong>：商品名称，商品类别</li>
</ul>
</li>
<li>(3) <strong>嵌入(Embedding)</strong>: 离散集合(查询集或推荐条目)==&gt;嵌入空间的映射。</li>
</ul>
<h2 id="4-推荐系统架构"><a href="#4-推荐系统架构" class="headerlink" title="4 **推荐系统架构"></a>4 **推荐系统架构</h2><p>​        推荐系统体系架构分成三部分: <strong>召回、打分、重排</strong></p>
<h3 id="4-1-召回-笼统排序"><a href="#4-1-召回-笼统排序" class="headerlink" title="4.1  召回(笼统排序)"></a>4.1  召回(笼统排序)</h3><p>​        即从众多信息中生成候选集合。如抖音从几十亿视频选出一千个。此过程需要快速查询。</p>
<p>​        方法：给定模型可有多个召回队列，每个队列都筛选不同类型的候选子集。</p>
<h4 id="4-1-1-召回方法："><a href="#4-1-1-召回方法：" class="headerlink" title="4.1.1 召回方法："></a>4.1.1 召回方法：</h4><ul>
<li>​        基于内容的过滤：</li>
<li>​        协同过滤：</li>
<li>​        基于神经网络方法：    </li>
</ul>
<h3 id="4-2-计分-精细排序"><a href="#4-2-计分-精细排序" class="headerlink" title="4.2  计分(精细排序)"></a>4.2  计分(精细排序)</h3><p>​        另一个模型对候选集进行评分和排序，以选择要显示给用户的集合（大约10个）。由于此模型评估的是商品的相对较小子集，因此系统可以依靠其他信息来使用更精确的模型。</p>
<h3 id="4-3-重排"><a href="#4-3-重排" class="headerlink" title="4.3  重排"></a>4.3  重排</h3><p>​        最后，系统必须考虑最终排名的其他限制。例如，系统删除用户明确不喜欢的项目或提高时效内容的得分。重新排序还可以帮助确保多样性，时效性和公平性。</p>
<h2 id="5-推荐系统实验方法"><a href="#5-推荐系统实验方法" class="headerlink" title="5  推荐系统实验方法"></a>5  推荐系统实验方法</h2><p>​        推荐系统主要有3种评测推荐效果的实验方法，即<strong>离线实验</strong>（ offline experiment）、<strong>用户调查</strong>（ user study）和<strong>在线实验</strong>（ online experiment）  </p>
<h3 id="5-1-离线试验"><a href="#5-1-离线试验" class="headerlink" title="5.1  离线试验"></a>5.1  离线试验</h3><pre><code>      离线实验的方法一般由如下几个步骤构成：
    (1) 通过日志系统获得用户行为数据，并按照一定格式生成一个标准的数据集
    (2) 将数据集按照一定的规则分成训练集和测试集；
    (3) 在训练集上训练用户兴趣模型，在测试集上进行预测；
    (4) 通过事先定义的离线指标评测算法在测试集上的预测结果。  
</code></pre><center>表1 离线实验的优缺点</center>

<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">不需要有对实际系统的控制权</td>
<td style="text-align:center">无法计算商业上关心的指标</td>
</tr>
<tr>
<td style="text-align:center">不需要用户参与实验、速度快，可以测试大量算法</td>
<td style="text-align:center">离线实验的指标和商业指标存在差距</td>
</tr>
</tbody>
</table>
</div>
<h3 id="5-2-用户调查"><a href="#5-2-用户调查" class="headerlink" title="5.2  用户调查"></a>5.2  用户调查</h3><p>​        用户调查需要有一些真实用户，让他们在需要测试的推荐系统上完成一些任务。在他们完成任务时，我们需要观察和记录他们的行为，并让他们回答一些问题。最后，我们需要通过分析他们的行为和答案了解测试系统的性能。</p>
<p>​        用户调查的优缺点也很明显。它的<strong>优点</strong>是可以获得很多体现用户主观感受的指标，相对在线实验风险很低，出现错误后很容易弥补。<strong>缺点</strong>是招募测试用户代价较大，很难组织大规模的测试用户，因此会使测试结果的统计意义不足。此外，在很多时候设计双盲实验非常困难，而且用户在测试环境下的行为和真实环境下的行为可能有所不同，因而在测试环境下收集的测试指标可能在真实环境下无法重现。</p>
<h3 id="5-3-在线实验"><a href="#5-3-在线实验" class="headerlink" title="5.3 在线实验"></a>5.3 在线实验</h3><p>将推荐系统上线做AB测试，将它和旧的算法进行比较 。</p>
<p>本文参考以下内容：<a href="https://zhuanlan.zhihu.com/p/87578318" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/87578318</a></p>
]]></content>
  </entry>
  <entry>
    <title>typora使用手册</title>
    <url>/typora%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>记录使用Typora编写markdown语法过程中一些实用技巧。</p>
<a id="more"></a>
<h2 id="1-快捷键："><a href="#1-快捷键：" class="headerlink" title="1 快捷键："></a>1 快捷键：</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Ctrl+1</td>
<td style="text-align:center">一阶标题</td>
<td style="text-align:center">Ctrl+B</td>
<td style="text-align:center">字体加粗</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+2</td>
<td style="text-align:center">二阶标题</td>
<td style="text-align:center">Ctrl+I</td>
<td style="text-align:center">字体倾斜</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+3</td>
<td style="text-align:center">三阶标题</td>
<td style="text-align:center">Ctrl+U</td>
<td style="text-align:center">下划线</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+4</td>
<td style="text-align:center">四阶标题</td>
<td style="text-align:center">Ctrl+Home</td>
<td style="text-align:center">返回Typora顶部</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+5</td>
<td style="text-align:center">五阶标题</td>
<td style="text-align:center">Ctrl+End</td>
<td style="text-align:center">返回Typora底部</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+6</td>
<td style="text-align:center">六阶标题</td>
<td style="text-align:center">Ctrl+T</td>
<td style="text-align:center">创建表格</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+L</td>
<td style="text-align:center">选中某句话</td>
<td style="text-align:center">Ctrl+K</td>
<td style="text-align:center">创建超链接</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+D</td>
<td style="text-align:center">选中某个单词</td>
<td style="text-align:center">Ctrl+F</td>
<td style="text-align:center">搜索</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+E</td>
<td style="text-align:center">选中相同格式的文字</td>
<td style="text-align:center">Ctrl+H</td>
<td style="text-align:center">搜索并替换</td>
</tr>
<tr>
<td style="text-align:center">Alt+Shift+5</td>
<td style="text-align:center">删除线</td>
<td style="text-align:center">Ctrl+Shift+I</td>
<td style="text-align:center">插入图片</td>
</tr>
</tbody>
</table>
</div>
]]></content>
  </entry>
  <entry>
    <title>LeetCode相爱相杀</title>
    <url>/leetcode/</url>
    <content><![CDATA[<p>与LeetCode的相爱相杀，在解题中找到编程的乐趣，记录解题思路与你共同探讨；</p>
<a id="more"></a>
<hr>
<h2 id="Num-113-路径总和"><a href="#Num-113-路径总和" class="headerlink" title="Num 113:路径总和"></a>Num 113:路径总和</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*题目描述：给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans_path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;Integer&gt; node_path = <span class="keyword">new</span> ArrayList&lt;&gt;();       </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        path_sum(root,sum);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> ans_path;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//整体思路：回溯,先序遍历思想，根左右</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">path_sum</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="comment">//空结点直接处理</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        node_path.add(root.val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;<span class="comment">//叶子节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(sum==root.val)&#123;<span class="comment">//当前值等于路径值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                ans_path.add(<span class="keyword">new</span> ArrayList&lt;&gt;(node_path));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sum-=root.val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            path_sum(root.left,sum);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">             path_sum(root.right,sum);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        node_path.remove(node_path.size()-<span class="number">1</span>);<span class="comment">//回溯</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="Num148-链表排序"><a href="#Num148-链表排序" class="headerlink" title="Num148:链表排序"></a>Num148:链表排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*题目描述：在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*输入: 4-&gt;2-&gt;1-&gt;3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*输出: 1-&gt;2-&gt;3-&gt;4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//归并排序思想</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)<span class="comment">//递归出口，只有一个节点或者没有节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ListNode mid_node = get_mid_node(head);<span class="comment">//得到中间节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ListNode right_head = mid_node.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mid_node.next = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> merge_List(sortList(head), sortList(right_head));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">get_mid_node</span><span class="params">(ListNode head)</span> </span>&#123;<span class="comment">//找链表的中间节点，快慢指针法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ListNode low_node = head, fast_node = head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (fast_node.next != <span class="keyword">null</span> &amp;&amp; fast_node.next.next != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            low_node = low_node.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            fast_node = fast_node.next.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> low_node;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge_List</span><span class="params">(ListNode p, ListNode q)</span> </span>&#123;<span class="comment">//合并p,q两个有序链表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ListNode cur_p = p, cur_q = q, head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (p.val &lt; q.val) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            head = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur_p = cur_p.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            head = q;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur_q = cur_q.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ListNode cur = head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (cur_q != <span class="keyword">null</span> &amp;&amp; cur_p != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (cur_q.val &lt; cur_p.val) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                cur.next = cur_q;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                cur_q = cur_q.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                cur = cur.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                cur.next = cur_p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                cur_p = cur_p.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                cur = cur.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (cur_p != <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur.next = cur_p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (cur_q != <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur.next = cur_q;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="Num560-和位k的子数组"><a href="#Num560-和位k的子数组" class="headerlink" title="Num560:和位k的子数组"></a>Num560:和位k的子数组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* Input:[3,4,7,2,-3,1,4,2]  k = 7</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* Output:7</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//key:累计和 value:出现的次数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     map.put(<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//解决数组从第0个元素开始选择</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">int</span> ans = <span class="number">0</span>,sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         sum+=nums[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="comment">//k = sum-(sum-k)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">if</span>(map.containsKey(sum-k))&#123;<span class="comment">//map中包含sum-k,即：当前的累计和sum减去sum-k的累计和等于k</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">             ans+=map.get(sum-k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">         &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            map.put(sum,map.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="Num-92反转部分链表"><a href="#Num-92反转部分链表" class="headerlink" title="Num 92反转部分链表"></a>Num 92反转部分链表</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*题目描述:反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ListNode root = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ListNode cur = head,root_cur = root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">int</span> index = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">while</span>(index!=m)&#123; <span class="comment">//小于m的节点，尾插法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        root_cur.next = cur;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        root_cur=root_cur.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cur=cur.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        index++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ListNode temp = cur;<span class="comment">//暂存当前节点的尾部，记录大于n之后的元素的前驱</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      root_cur.next=<span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//头插法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">while</span>(index&lt;=n)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          head = cur.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          cur.next=root_cur.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          root_cur.next =cur;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          cur = head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         index++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      root_cur = temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span>(cur!=<span class="keyword">null</span>)<span class="comment">//n之后的直接插入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            root_cur.next = c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">return</span> root.next;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="Num-129-根节点到叶子节点之和"><a href="#Num-129-根节点到叶子节点之和" class="headerlink" title="Num 129:根节点到叶子节点之和"></a>Num 129:根节点到叶子节点之和</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*	题目描述:给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*	输入: [1,2,3]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*    1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*   / \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*  2   3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*	输出: 25</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*	解释:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*	从根到叶子节点路径 1-&gt;2 代表数字 12.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*	从根到叶子节点路径 1-&gt;3 代表数字 13.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*	因此，数字总和 = 12 + 13 = 25.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sumNumber(root,<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//先序遍历思想</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sumNumber</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;<span class="comment">//叶子节点,值直接返回</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            ans += <span class="number">10</span>*sum+root.val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         sumNumber(root.left,<span class="number">10</span>*sum+root.val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">         sumNumber(root.right,<span class="number">10</span>*sum+root.val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="Num-701-二叉搜索树的插入操作"><a href="#Num-701-二叉搜索树的插入操作" class="headerlink" title="Num 701: 二叉搜索树的插入操作"></a>Num 701: 二叉搜索树的插入操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//迭代法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            TreeNode cur = root, p = root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                p = cur;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (cur.val &lt; val) </span></pre></td></tr><tr><td class="code"><pre><span class="line">                    cur = cur.right;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">else</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">                    cur = cur.left;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            TreeNode new_code = <span class="keyword">new</span> TreeNode(val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (p.val &lt; val) </span></pre></td></tr><tr><td class="code"><pre><span class="line">                p.right = new_code;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                p.left = new_code;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//递归法，函数终止条件,插入新节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (root.val &gt; val)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                root.left = insertIntoBST(root.left, val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                root.right = insertIntoBST(root.right, val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> root;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="Num230-二叉搜索树的第k小个元素"><a href="#Num230-二叉搜索树的第k小个元素" class="headerlink" title="Num230 :二叉搜索树的第k小个元素"></a>Num230 :二叉搜索树的第k小个元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 题目描述:给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* 输入: root = [3,1,4,null,2], k = 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*   3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* / \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* 1   4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*   2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">* 输出: 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans =<span class="number">0</span>,count=<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        kthSmallests(root,k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//中序遍历思想</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kthSmallests</span><span class="params">(TreeNode root,<span class="keyword">int</span> k)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(root ==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        kthSmallests(root.left,k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(++count==k)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ans = root.val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        kthSmallests(root.right,k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="Num61-旋转链表"><a href="#Num61-旋转链表" class="headerlink" title="Num61 旋转链表"></a>Num61 旋转链表</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**	题目描述:给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/** 分情况讨论：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">        1 head ==null ||k%listnode.size()==0 直接返回结果</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">        2 找到链表的倒数第k个节点，将链表的前size-k个节点插入到链表的末尾</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    **/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> list_size = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ListNode cur =head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            list_size++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur=cur.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="comment">//求链表大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        k = k%list_size;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ListNode k_node_last = find_last_k(head,k);<span class="comment">//找到倒数第k个节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        cur = k_node_last;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(cur.next!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur=cur.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="comment">//到链表末尾</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(head!=k_node_last)&#123;<span class="comment">//前size-k个节点插入到后面</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur.next = head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur =head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            head= head.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cur.next =<span class="keyword">null</span>;<span class="comment">//末尾指向空结点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> k_node_last;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">find_last_k</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span></span>&#123;<span class="comment">//找到倒数第k个节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ListNode cur=head,pre =head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(++index&lt;k)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur =cur.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(cur.next!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            pre =pre.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur =cur.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> pre;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>Num 86 分割链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 题目描述:给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*	输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*	输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/** </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    * 1 小于x的存到一个链表root中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    * 2 大于等于x的放在原链表中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    * 3 1--&gt;2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    **/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ListNode root = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ListNode cur = root,p = head,pre_p=head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(p.val&lt;x)&#123;<span class="comment">//小于x，赋值给新节点，并在原链表中删除该节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                ListNode temp =p.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span>(p==head)<span class="comment">//考虑首节点小于x,直接移动head</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    head = head.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    pre_p.next = p.next;<span class="comment">//删除p</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                cur.next = p;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                cur = p;<span class="comment">//尾插法插入小于x的节点到root中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                p = temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//&gt;=x,直接后移</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                pre_p = p;             </span></pre></td></tr><tr><td class="code"><pre><span class="line">                p = p.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cur.next = head;<span class="comment">//合并</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> root.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
